<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-解構賦值</title>
    <url>/posts/Es6-destructuringAssignment/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>解構賦值(Destructuring Assignment)是在ES6的一個新特性，讓我們在撰寫物件、陣列時可以把在裡頭的資料解開擷取成為獨立的變數，能夠更簡短並增加閱讀性。<br>以下為他的說明：</p>
<blockquote>
<p>The destructuring assignment syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and object literals</p>
</blockquote>
<span id="more"></span>

<p>上面所說的就是解構賦值的用法如同<strong>鏡子</strong>(mirror)般，對應陣列or物件的結構，將資料從右邊往左邊送，只不過內容的位置順序不變（鏡子會左右顛倒），也就是一種樣式對應(pattern)的方法。</p>
<p>介紹比較常用的情況：</p>
<ul>
<li>從陣列解構賦值</li>
<li>從物件解構賦值</li>
<li>解構賦值給定預設值</li>
<li>搭配函式的傳入參數使用</li>
</ul>
<h1 id="陣列"><a href="#陣列" class="headerlink" title="陣列"></a>陣列</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b, c, , d, f] = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a=&#x27;h&#x27;, b=&#x27;e&#x27;, c=&#x27;l&#x27;, d=&#x27;o&#x27; 留空白就會跳過</span></span><br><span class="line"><span class="comment">// f=undefined  如果左方變數多於右方，則會顯示undefined</span></span><br><span class="line"><span class="comment">// 這邊也順便帶入一個概念是分解字串</span></span><br></pre></td></tr></table></figure>

<p>接下來要說的是我覺得很方便的用法“互換”，一般我們要互換兩個變數要多宣告一個第三變數才能完成，這邊我們可以直接完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此時的 a=2, b=1</span></span><br></pre></td></tr></table></figure>

<h1 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h1><p>這邊的概念和陣列一樣，不過陣列是利用順序的索引值對照，而物件是用屬性名稱來對應(所以沒有順序性)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family = &#123; <span class="attr">me</span>: <span class="string">&#x27;colin&#x27;</span>, <span class="attr">sis</span>: <span class="string">&#x27;candy&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般寫法</span></span><br><span class="line"><span class="keyword">let</span> me = family.me;</span><br><span class="line"><span class="keyword">let</span> sis = family.sis;</span><br><span class="line"></span><br><span class="line"><span class="comment">//縮寫</span></span><br><span class="line"><span class="keyword">let</span> &#123;me, sis&#125; = family;</span><br><span class="line"></span><br><span class="line"><span class="comment">// me:colin, sis:candy</span></span><br></pre></td></tr></table></figure>

<p>物件的解構還能重新賦予變數的名稱</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> player = &#123; <span class="attr">jordan</span>: <span class="string">&#x27;喬丹&#x27;</span>, <span class="attr">wade</span>: <span class="string">&#x27;偉德&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">jordan</span>: king &#125; = player;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此時king的值為&#x27;喬丹&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">jordan</span>: king, <span class="attr">family</span>: [, ...member] &#125; = &#123; <span class="attr">jordan</span>: <span class="string">&#x27;喬丹&#x27;</span>, <span class="attr">family</span>: [<span class="string">&#x27;阿姨&#x27;</span>, <span class="string">&#x27;老媽&#x27;</span>, <span class="string">&#x27;老爸&#x27;</span>] &#125;</span><br><span class="line"><span class="built_in">console</span>.log(king, member); <span class="comment">// 請問答案是什麼？ Ans: king:&#x27;喬丹&#x27;, member: [&#x27;老媽&#x27;, &#x27;老爸&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p.s 其餘運算子用法 (...變數)：將陣列展開成個別值灑進去。</span></span><br></pre></td></tr></table></figure>

<h1 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h1><p>在等號左邊是可以給預設值的，避免未被賦值時造成undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [jordan = <span class="string">&#x27;喬丹&#x27;</span>, lebron = <span class="string">&#x27;雷霸龍&#x27;</span>] = [<span class="string">&#x27;阿明&#x27;</span>];</span><br><span class="line"><span class="comment">// jordan值為&#x27;阿明&#x27;</span></span><br><span class="line"><span class="comment">// lebron則為預設值&#x27;雷霸龍&#x27;</span></span><br></pre></td></tr></table></figure>

<p>陷阱題</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a =<span class="string">&#x27;hello&#x27;</span> &#125; = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> [ b =<span class="string">&#x27;hello&#x27;</span> ] = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// 此時 a, b 分別為什麼呢？</span></span><br></pre></td></tr></table></figure>

<h1 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h1><p>在函式要傳參數時也可以使用解構，參數一樣能夠自訂變數名稱、順序、預設值等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">&#123;a = <span class="number">1</span>, b&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) <span class="comment">// 3</span></span><br><span class="line">func(&#123;<span class="attr">b</span>: <span class="number">2</span>&#125;) <span class="comment">// 3</span></span><br><span class="line">func(&#123;<span class="attr">b</span>: <span class="number">6</span>, <span class="attr">a</span>: <span class="number">3</span>&#125;) <span class="comment">// 9</span></span><br><span class="line">func(&#123;<span class="attr">a</span>: <span class="literal">null</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>註：所以在函式傳入參數中作解構賦值時，給定null值時會導致預設值無用，請記住這一點。當數字運算時，null相當於0。</p>
</blockquote>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用HTML直接下載pdf</title>
    <url>/posts/Html-downloadPdf/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在嘗試利用 html的<code>&lt;a&gt;</code>標籤做下載檔案的功能，發現了一件事情，其他檔案能正常下載<br><del>除了pdf</del></p>
<p>當你的程式是寫<code>&lt;a href=&quot;test.pdf&quot; /&gt;</code>，當點擊連結時，會使用在當前瀏覽器中打開該文件給予預覽。<br>這就會不符合我的需求，我希望的是直接給使用者下載，不需要再打開預覽文件。</p>
<span id="more"></span>

<h1 id="HTML-lt-a-gt-download屬性"><a href="#HTML-lt-a-gt-download屬性" class="headerlink" title="HTML &lt;a&gt; download屬性"></a>HTML <code>&lt;a&gt;</code> download屬性</h1><p>爬了一下文發現很簡單！只要在a標籤裡再加上一個download就好～<br><code>&lt;a href=&quot;yourfile.pdf&quot; download=&quot;newFileName&quot;&gt;下載檔案&lt;/a&gt;</code><br>這邊的newFileName是讓你可以指定使用者下載下來時的檔名，<br>如果留空，就會默認為伺服器端的名稱，<br>如下：<br><code>&lt;a href=&quot;test.pdf&quot; download&gt;click&lt;/a&gt;</code></p>
<h1 id="HTML-lt-a-gt-target屬性"><a href="#HTML-lt-a-gt-target屬性" class="headerlink" title="HTML &lt;a&gt; target屬性"></a>HTML <code>&lt;a&gt;</code> target屬性</h1><p>既然都說到<code>&lt;a&gt;</code>標籤了，那就再加上一點補充～<br>利用a標籤的時候不外乎就是要開啟一個連結或是下載檔案，那我們在打開連接的方式就有分成幾種：</p>
<ul>
<li>直接於所在的視窗中打開（_self）</li>
<li>另開一個視窗（_blank）</li>
<li>開啟於父層框架（_parent）</li>
</ul>
]]></content>
      <tags>
        <tag>html</tag>
        <tag>download</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 陣列</title>
    <url>/posts/Js-array/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這週與前端小夥伴們發起了 JavaScript 資料結構 (data structure) 讀書會，二話不說用微薄的薪資擠出了些孔方兄購入兩本工具書規劃一下學習計畫，這週從最基礎的陣列 (Array) 走起！<br>是哪兩本書我會放在最後給大家參考，也希望有想學習這方面的小夥伴每週跟著我的腳步一起成長八 ❤️</p>
<span id="more"></span>

<h2 id="陣列-Array"><a href="#陣列-Array" class="headerlink" title="陣列 Array"></a>陣列 Array</h2><p>在眾多的語言中，陣列是大家原生都有支援的類型，是最常見的負責<strong>存放一系列相同類別資料</strong>的方法。<br><del>但在 JS 裡是可以在裡頭儲存不同類型的值</del>。這部分我們就不探討了。</p>
<h3 id="為什麼要用陣列"><a href="#為什麼要用陣列" class="headerlink" title="為什麼要用陣列"></a>為什麼要用陣列</h3><p>假設有一個需求，記錄下這星期每一天吃的熱量總數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calorieMon = <span class="number">3500</span>;</span><br><span class="line"><span class="keyword">var</span> calorieTue = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieWed = <span class="number">2700</span>;</span><br><span class="line"><span class="keyword">var</span> calorieThu = <span class="number">3200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieFri = <span class="number">2200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieSat = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieSun = <span class="number">4800</span>;</span><br></pre></td></tr></table></figure>

<p>方法沒有不行但肯定不是最佳。以這種方式，如果只有一週自然只有 7 個變數，那要記錄半年呢？<br>這個時候就要慶幸有陣列來幫助我們更有效率解決：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">0</span>] = <span class="number">3500</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">1</span>] = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">2</span>] = <span class="number">2700</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">3</span>] = <span class="number">3200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">4</span>] = <span class="number">2200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">5</span>] = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">6</span>] = <span class="number">4800</span>;</span><br><span class="line"></span><br><span class="line">calorieArr = [<span class="number">3500</span>, <span class="number">5000</span>, <span class="number">2700</span>, <span class="number">3200</span>, <span class="number">2200</span>, <span class="number">3000</span>, <span class="number">4800</span>];</span><br></pre></td></tr></table></figure>

<h3 id="宣告和初始化"><a href="#宣告和初始化" class="headerlink" title="宣告和初始化"></a>宣告和初始化</h3><p>宣告的方式有幾種：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>); <span class="comment">// 指定長度</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Leo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">// 最常使用的宣告方式</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Leo&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="基本屬性"><a href="#基本屬性" class="headerlink" title="基本屬性"></a>基本屬性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 陣列元素的數量</span></span><br><span class="line">arr.length</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存取指定位置的元素可以使用中括號傳遞索引值    p.s.索引是從 0 開始</span></span><br><span class="line">arr[index]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 藉由迴圈遍歷陣列，輸出全部元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元素的添加和刪除"><a href="#元素的添加和刪除" class="headerlink" title="元素的添加和刪除"></a>元素的添加和刪除</h3><p>以下我們就使用這個範例來做一些教學八</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>添加元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 先來個陽春直覺版</span></span><br><span class="line">arr[arr.length] = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// arr = [0, 1, 2, 3, 4, 5, 6];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push 屬性(加入元素位於“尾端”)</span></span><br><span class="line">arr.push(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// arr = [0, 1, 2, 3, 4, 5, 6, 7];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unshift 屬性(加入元素位於“首端”)</span></span><br><span class="line">arr.unshift(-<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// arr = [-1, 0, 1, 2, 3, 4, 5, 6, 7];</span></span><br></pre></td></tr></table></figure>

<p>刪除元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// pop 屬性(刪除元素位於“尾端”)</span></span><br><span class="line">arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// arr = [0, 1, 2, 3, 4];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift 屬性(刪除元素位於“首端”)</span></span><br><span class="line">arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// arr = [1, 2, 3, 4];</span></span><br></pre></td></tr></table></figure>

<p>在後面的章節裡，會藉由 push, pop 方法，模擬<strong>堆疊</strong>資料結構；而 shift 和 unshift 則模擬<strong>佇列</strong>資料結構。</p>
<p>到這邊為止，介紹了從頭尾去新增及刪除元素，那我們要怎麼從中間去操作呢？<br>讓我們接下去看到 splice 屬性，這也是我覺得很便利的方法！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// splice 屬性</span></span><br><span class="line"><span class="comment">// splice(要操作的索引值, 刪除的個數, 增加的元素(選填，可多個))</span></span><br><span class="line">arr.splice(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// arr = [0, 1, 2, 5]</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">// 在第三索引的地方插入兩個元素 8, 8，因為沒有要刪除所以個數寫上 0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// arr = [0, 8, 8, 1, 2, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="二維及多維陣列"><a href="#二維及多維陣列" class="headerlink" title="二維及多維陣列"></a>二維及多維陣列</h3><p>二維用表格來解釋會相當容易理解，下方是一個 3x3 的表格也代表著一種二維陣列</p>
<table>
<thead>
<tr>
<th align="center">A1</th>
<th align="center">A2</th>
<th align="center">A3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A4</td>
<td align="center">A5</td>
<td align="center">A6</td>
</tr>
<tr>
<td align="center">A7</td>
<td align="center">A8</td>
<td align="center">A9</td>
</tr>
</tbody></table>
<p>A1的索引值：arr[0][0]<br>A2: arr[0][1]<br>A3: arr[0][2]…依此類推</p>
<p>幾維陣列的遍歷就要用幾層迴圈作。</p>
<h3 id="陣列方法"><a href="#陣列方法" class="headerlink" title="陣列方法"></a>陣列方法</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">concat</td>
<td align="left">連接多個陣列，return 結果</td>
</tr>
<tr>
<td align="center">every</td>
<td align="left">對陣列每一個元素運行函數，每一個元素都是 true，才會 return true</td>
</tr>
<tr>
<td align="center">filter</td>
<td align="left">對陣列每一個元素運行函數，集合  true 的元素 return 陣列</td>
</tr>
<tr>
<td align="center">forEach</td>
<td align="left">對陣列每一個元素運行函數</td>
</tr>
<tr>
<td align="center">join</td>
<td align="left">將所有元素串成一個字串</td>
</tr>
<tr>
<td align="center">indexOf</td>
<td align="left">return 第一個相等參數的索引值，無符合 return -1</td>
</tr>
<tr>
<td align="center">lastIndexOf</td>
<td align="left">return 最後一個相等參數的索引值，無符合 return -1</td>
</tr>
<tr>
<td align="center">map</td>
<td align="left">對陣列每一個元素運行函數，return 每次函數所呼叫的結果所組成之陣列</td>
</tr>
<tr>
<td align="center">reverse</td>
<td align="left">反轉陣列裡的元素</td>
</tr>
<tr>
<td align="center">slice</td>
<td align="left">傳入索引值，return 索引範圍內的元素新陣列</td>
</tr>
<tr>
<td align="center">some</td>
<td align="left">對陣列每一個元素運行函數，有任意 true ，return true</td>
</tr>
<tr>
<td align="center">sort</td>
<td align="left">按照 ASCII 值做排序，支援傳入指定排序函數做參數</td>
</tr>
<tr>
<td align="center">toString</td>
<td align="left">return 將陣列轉字串</td>
</tr>
<tr>
<td align="center">valueOf</td>
<td align="left">和 toString 相似，return 將陣列轉字串</td>
</tr>
</tbody></table>
<h2 id="工具書"><a href="#工具書" class="headerlink" title="工具書"></a>工具書</h2><ul>
<li>JavaScript 資料結構及演算法實作 - Loiane Groner</li>
<li>演算法圖鑑 - 石田保輝、宮崎修一</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>array</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-SEO Google Search Console</title>
    <url>/posts/Seo-hexoByGoogleSearchConsole/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>發布了自己的部落格後，是不是發現在 Google 搜尋引擎找不著自己的網站呀！<br>難道是自己已經邊緣到被全世界排擠了嗎…QAQ<br>雖然這也有可能是一個原因啦…(XD，不鬧了</p>
<span id="more"></span>

<h1 id="Google-Search-Console"><a href="#Google-Search-Console" class="headerlink" title="Google Search Console"></a>Google Search Console</h1><p>它的前身叫做 Google Webmaster Tool，而它的作用就是專門管理你的網站在搜尋引擎的 SEO 表現，<br>如果你想知道你的網站熱門的關鍵字、曝光或點擊數量，那麼你一定要試試。</p>
<p>要讓搜尋引擎能找到自己的網站，我們要先進入 <span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2guZ29vZ2xlLmNvbS9zZWFyY2gtY29uc29sZS9hYm91dA==">Google Search Console<i class="fa fa-external-link-alt"></i></span> 註冊服務並進行一些設定。</p>
<h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><h2 id="驗證網站"><a href="#驗證網站" class="headerlink" title="驗證網站"></a>驗證網站</h2><p>一開始必須先設定驗證你的網站（如下圖）。</p>
<img src="/posts/Seo-hexoByGoogleSearchConsole/gsc.jpg" class="">
<p>有購買網域的話，就可以使用左邊的驗證；如果像我一樣是利用 Git Page 發布的，就選擇右邊“網址前置字元”，<br>輸入完你的網址後會要去驗證，我這邊使用的是 HTML 檔案，當然你可以選擇你喜歡的方式驗證。</p>
<ol>
<li>點擊按鈕<strong>下載</strong>檔案。<img src="/posts/Seo-hexoByGoogleSearchConsole/gsc1.jpg" class=""></li>
<li>直接將檔案放進來你會發現驗證是失敗的，所以我們要先<strong>編輯</strong>一下這個檔案！</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: <span class="literal">false</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">google-site-verification: googleb6bf13d6a5baaaaaaaaa.html</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>將<strong>檔案放到 hexo/ source 底下</strong>。</p>
<img src="/posts/Seo-hexoByGoogleSearchConsole/gsc2.png" class=""></li>
<li><p>不免俗的還是要提醒一下，請記得將 Hexo <strong>部署</strong>到 GitHub Pages。</p>
</li>
<li><p>最後按下驗證的按鈕即可。</p>
</li>
</ol>
<p>大概等待個兩三天 GSC 就會分析出你的網站有哪些關鍵字熱門、需要優化的地方，基本上你就照著他提供方向去做調整，網站的 SEO 就會大大到提升了。</p>
<h2 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h2><p>說到 Google Search Conosle 那就順便提一下 Sitemap 吧~<br>以往建立一個新的網站時，如果沒有強而有力的網站互聯(ㄏㄨㄟˋ)的話，就很難被爬蟲給爬到，所以這時就要給自己的 Hexo 安裝套件是專門幫忙生成 sitemap.xml ，而這檔案是提交給搜尋引擎爬蟲使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<p>在終端機輸入完指令後就可以部署上去。<br>接著來到 Google Search Console 上的 “Sitemap” 頁面，並在新增欄位輸入 sitemap.xml 提交就完成囉。</p>
<img src="/posts/Seo-hexoByGoogleSearchConsole/gsc3.png" class="">

<p>都設定好了以後， Google 爬蟲只要定期去看 sitemap 檔案是否更新，就會去爬你的網站並做更新囉！<br>一般來說部落格要被搜尋引擎收錄大概會需要 7~14 天不等，當然也有更快的，就看運氣了😂</p>
<p>這篇就到這，我們下次見👋🏻</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
        <tag>Google Search Console</tag>
      </tags>
  </entry>
  <entry>
    <title>一失足掉進的坑 Hexo Config</title>
    <url>/posts/Hexo-config-permalink/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有在使用 Hexo Blog 的朋友一定知道他有很多設定可以玩！除了一般的標題、簡介、相關連結外，還有分頁、閱讀進度、總閱覽人數…等等一大堆。<br>今日心血來潮想要把部落格的 config 設定弄的更完整一些，沒有想到居然在之中受困數個小時…，真的覺得自己好笑又好氣😓</p>
<span id="more"></span>

<h1 id="permalink-永久連結"><a href="#permalink-永久連結" class="headerlink" title="permalink 永久連結"></a>permalink 永久連結</h1><p>這是設定關於網站文章的連結（ URL ），就是點進你的文章後上面所顯使的連結樣式</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>       <span class="comment"># 預設 Ex: 2013/07/14/hello-world/</span></span><br></pre></td></tr></table></figure>

<p>Hexo 文件有告訴大家說可以使用變數(文章尾端附圖)以及 Front-matter 做變化。看到這裡根本不知道不行自訂對吧！對吧！對吧…?<br>所以我就自作主張改成了以下這樣：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:title/</span>       <span class="comment"># Ex: posts/hello-world/</span></span><br></pre></td></tr></table></figure>

<p>原本想說網址太長多少會影響 SEO 的表現，所以我不想要時間在前面佔空間，還有這樣 public 資料夾的文章會被收在 posts 的資料夾裡不會散落一地，看起來才會讓我蘇湖🤤。<br>接下來 Deploy 出去就發現文章都連不進去啦啦啦😱，在改這個設定的時候，我已經有幾篇文章了，以為是動到了已發布文章的路徑才造成如此，便開始我的 Debug 之路，翻啊找啊爬啊根本沒有搜尋到什麼相關的東西，回頭重新讀了一下文件，才領悟到無法自訂呀～只能透過 permalink_defaults 改寫你想要的東西。於是我就將我的 category 預設為 posts 然後改寫。</p>
<img src="/posts/Hexo-config-permalink/permalinks1.png" class="">

<img src="/posts/Hexo-config-permalink/permalinks2.png" class="">

<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>不要自作聰明… 😂</p>
<img src="/posts/Hexo-config-permalink/Permalinks.png" class="" title="[Permalink可用變數]">
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 現今主流的 JS 框架之一</title>
    <url>/posts/Vue-know/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次和Vue碰面是在我大四實習時，剛好遇到公司開始推行同仁使用框架開發，也讓我這個菜鳥搭上前端框架的順風車。<br>趁現在有空閒之餘來整理一下當初的筆記，也順帶複習一下 Vue.js！</p>
<span id="more"></span>

<h1 id="何謂框架"><a href="#何謂框架" class="headerlink" title="何謂框架"></a>何謂框架</h1><p>框架(framework)，是指協助開發者能更容易地進行網頁製作的工具，將一些複雜的語法及工具以簡易的方式撰寫，進而提升效率及效能。就像是設計一台汽車，已經將模型給你了，你只需要對設計圖進行配色就可以完成，而上色這個部分和周邊的配件就是可以讓大家去精進功力地方了。<br>而現行較主流的框架為 Vue, React, Angular 等等。</p>
<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>Vue是一種javascript的一種漸進式(progressive)框架，是以 View(視圖層)為基礎，與其他框架不同的是，他的目標是透過簡單的API提供開發者實作資料綁定和操作網頁上的元件，也因為核心(宣告式渲染、元件系統)關注在狀態和畫面的同步層級上，所以能夠輕易地與其他 js 函式庫、前端開發工具等等的做整合。</p>
<img src="/posts/Vue-know/vue-logo.jpeg" class="">

<h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><ul>
<li>輕量型框架：架構輕量、效能好</li>
<li>提供資料綁定(Data Binding)的功能：可以將值關聯到 Html 標籤或 Attribute 上，變更資料、樣式</li>
<li>虛擬Dom(Virtual DOM)：以 javascript 物件模擬特定的 Dom 結構而產生的樹狀節構。不直接操作 Dom 元素，而是等一個段落後，再將這些變更回真實Dom上</li>
<li>元件化系統(Components system)：提供 Dom 強大的擴充性，也可將部分程式碼封裝起來，供開發者維護、重複使用</li>
<li>指示詞(Directive)：內建許多指示詞(v-開頭)，用來進行程式邏輯的判斷</li>
<li>Vue路由器(Router)：利用它建構一個基本卻完整的路由庫，來操作瀏覽器上/下一頁的流程，建立 SPA 完整單頁式應用的能力。</li>
</ul>
]]></content>
      <tags>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>來聊聊 Type Script</title>
    <url>/posts/Ts-know/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次在專案裡與 TS 相遇，那就不免俗的了解囉！<br>稍微簡介一下～<br>TypeScript是由微軟開發的一種能用來編譯出JavaScript程式碼的程式語言，因其比JS還多了一道編譯手續，能夠在編譯階段找出語法上的問題，而且也添加了型別檢查的機制，讓程式更容易閱讀與偵錯，也更適合開發大型的專案。<br>白話一點來說，JS可以通過TS編譯器來編譯，而且還能夠實現JavaScript的版本轉換(例如ES6轉ES5)</p>
<span id="more"></span>

<img src="/posts/Ts-know/js-ts.jpg" class="">

<h1 id="安裝與設定"><a href="#安裝與設定" class="headerlink" title="安裝與設定"></a>安裝與設定</h1><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>我們要先設定好Node.js和npm環境，建議使用Node.js最新的LTS版本。<br>Node.js是JavaScript程式的執行環境，讓我們不需要開啟瀏覽器也可以執行JS。而npm則是JS的套件管理器，常與Node.js一同被安裝。</p>
<p>Windows的使用者可以直接到<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Node.js官方網站<i class="fa fa-external-link-alt"></i></span>下載，而Linux或MacOS的使用者可以參考<span class="exturl" data-url="aHR0cHM6Ly9tYWdpY2xlbi5vcmcvbGludXgtaW5zdGFsbC1ub2RlanMv">這篇文章<i class="fa fa-external-link-alt"></i></span>安裝指定版本。</p>
<h2 id="tsc"><a href="#tsc" class="headerlink" title="tsc"></a>tsc</h2><p>tsc是TypeScript程式的編譯器，能夠將TS編譯成JS。<br>執行以下npm指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure>

<p>關於編譯器的設定，我就先不說明，一開始花太多時間在這會顯得有點浪費且沒意思，畢竟內容很龐大也很複雜。</p>
<hr>
<h1 id="簡單的範例"><a href="#簡單的範例" class="headerlink" title="簡單的範例"></a>簡單的範例</h1><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(colin)</span><br></pre></td></tr></table></figure>

<p>這邊唯一和我們學過的JavaScript不同，就是func這個函式的傳入參數多一個 :string 的指示詞，這東西在ＴＳ裡稱做類型註解。這邊就是說傳入的參數只接受字串(string)的型態，只要是其他型別在呼叫或是執行時就會報錯。</p>
<p>對於函式而言，會有傳入參數和回傳值兩種情況，那麼我們就要養成習慣。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(colin)</span><br></pre></td></tr></table></figure>

<p>上面這表示回傳值的型態也是string類型，順帶一提，如果函式沒有回傳值時可以使用 void，相信很多人都有看過吧，這就是專門為沒有回傳值的函式所準備的類型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">name: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">&quot;Colin&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>這裡的意思是 name這個變數能接受的型態為字串(string)與數字(number)，而且預設值為 Colin字串。</p>
<hr>
]]></content>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>為什麼Vue中的data有時候會看到return，而有時候卻沒有？</title>
    <url>/posts/Vue-data/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>當你在剛接觸 Vue 的時候是不是有想過一件事情，文件上或人家範例的 data 寫方式似乎不太一樣…🤔😣</p>
<span id="more"></span>

<h1 id="疑難排解"><a href="#疑難排解" class="headerlink" title="疑難排解"></a>疑難排解</h1><p>在簡單的vue實例中看到的data屬性如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> app = newVue(&#123;</span><br><span class="line">    el: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在使用組件化的項目中使用的形式是如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            msg:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而這兩邊的差異呢就在於 <strong>不使用return包覆</strong> 的資料會在全局都可見，這會造成變數污染。<br>反之 <strong>用return的資料</strong> 就只會在當前的component生效而已，不會影響到其他組件。</p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>什麼時候該使用『 const vm = this 』</title>
    <url>/posts/Vue-this/</url>
    <content><![CDATA[<p> <strong>影響this的是在於<em>函式的呼叫方式</em></strong></p>
<p>以下為this的範例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">reverseText: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.text.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>在第一個範例中，this運行後都是在這個元件底下<br>並沒有另外的函式在內（ex: forEach）<br>全部的this都是指向<strong>Vue的該元件</strong><br>因此不需要另外使用 vm = this</p>
<p>至於使用 vm = this 可以避免內部有其他函式叫<br>導致 this 的運作不如預期。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因為在&quot;&quot;內層函式&quot;&quot;filter的函式內使用到this，指向會跑掉，所以需要使用vm。</span></span><br><span class="line">filterArray: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> vm.arrayData.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.name.match(vm.filterText)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>除了使用 filter/ forEach 會讓this指向window外，函式在直接呼叫的時候this也會指向window</strong></p>
]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/hello-world/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>讓爬蟲程式照著規則來 robots.txt</title>
    <url>/posts/Seo-robotsTxt/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果有了解過 SEO ，那你可能有聽說過『 robots.txt 』這個名字。<br>主要用來避免網站要求太多，導致超載(<del>要求太多會人家討厭的</del><br>而簡單來說，他就是來讓爬蟲程式聽話的一個檔案，像是該爬這裡、不該走這裡，<br>但是但是但是…有機率會不聽話失效🤫。</p>
<p><img src="https://webris.org/wp-content/uploads/2017/12/robots_txt_file_explained.gif" alt="robots.txt示意圖"></p>
<span id="more"></span>

<h1 id="建議使用的理由"><a href="#建議使用的理由" class="headerlink" title="建議使用的理由"></a>建議使用的理由</h1><p>robots.txt 檔案主用途在於管理爬蟲對自己網站的流量，<strong>直接了當的與爬蟲溝通</strong>；“正常情況下”可以讓搜尋引擎的結果不顯示特定檔案。<br>以下幾種情況是建議使用的：</p>
<ul>
<li>網站還有未完成或需要測試時。</li>
<li>有網頁內容重複性太高時。</li>
<li>網站內有一些相對不重要的資訊，浪費資源。</li>
<li>擁有機密檔案。</li>
</ul>
<h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><ul>
<li><p>他網有連結到設置封鎖的網頁，索引還是會被建立。<br>只是要自己的網頁不要出現在搜尋引擎上就請不要用這個方法，就算你使用 robots.txt 來限制，只要有別的網頁有說明文字指向你，那麼即使爬蟲未造訪這裡，也會被建立成索引。以下提供其他的方法給大家：密碼保護、noindex。</p>
</li>
<li><p>不是所有的搜尋引擎都會支援。<br>不同的檢索器會自行決定要不要遵守，所以並不是強制性的。（Googlebot是好寶寶他會）</p>
</li>
<li><p>不同檢索器語法的使用不一定相同。<br>我們平時熟知的大宗搜尋引擎都聽得懂，但就是有人會理解成不同的意思，這時候我們就必須應材施教了。</p>
</li>
</ul>
<h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><h2 id="基本規則"><a href="#基本規則" class="headerlink" title="基本規則"></a>基本規則</h2><p>一開始先介紹一些基本的規範、格式～</p>
<ul>
<li>一個網站只能存在一個 robots.txt 檔案。</li>
<li>檔名只能是 robots.txt ，不能當手遊的名字一樣亂取…PikaChiu（喂🤭</li>
<li>檔案要放在根目錄。</li>
</ul>
<h2 id="建立檔案並新增規則"><a href="#建立檔案並新增規則" class="headerlink" title="建立檔案並新增規則"></a>建立檔案並新增規則</h2><p>第一步先用編輯器建立一個名叫 robots.txt 的文字檔，這邊要<strong>注意</strong>的是不要用文書處理軟體，人家說有可能會有問題。<br>再來就是重頭戲了，告訴你用三個單字搞定</p>
<ul>
<li>User_Agent: 爬蟲的名字，例如：Googlebot。</li>
<li>Allow: 允許人家“可以”爬的。</li>
<li>Disallow: “不同意”人家進來爬的。</li>
</ul>
<p>好了教完了😂😂😂</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>用一些範例來講解，大家應該就可以很快上手。</p>

]]></content>
      <tags>
        <tag>SEO</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
</search>
