<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凹逗工程師</title>
  
  <subtitle>成為一個更好的人</subtitle>
  <link href="https://colinchiu87.github.io/atom.xml" rel="self"/>
  
  <link href="https://colinchiu87.github.io/"/>
  <updated>2024-07-13T10:03:40.102Z</updated>
  <id>https://colinchiu87.github.io/</id>
  
  <author>
    <name>Kuan Ru</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『Git』怎麼寫 Commit Message 更好</title>
    <link href="https://colinchiu87.github.io/posts/Git-commitMessage/"/>
    <id>https://colinchiu87.github.io/posts/Git-commitMessage/</id>
    <published>2024-06-10T07:25:04.000Z</published>
    <updated>2024-07-13T10:03:40.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前在開發的時候，總覺得沒有人會去看 git commit 的訊息，所以總是想寫什麼就寫什麼。<br>雖然都會標記一下[類型]：新增功能、刪除…之類的，但是真的超陽春。<br>直到最近，開始幫人家 Review code，才渴望人家的 Commit Message 可以留完整一點給我！</p><p>真心建議大家，早點培養起 commit message 良好習慣就越好！</p><img src="/posts/Git-commitMessage/gitMessage1.jpeg" class=""><span id="more"></span><h2 id="Better-git-commit-message"><a href="#Better-git-commit-message" class="headerlink" title="Better git commit message"></a>Better git commit message</h2><h3 id="為什麼應該要學習更好的-commit-message-撰寫？"><a href="#為什麼應該要學習更好的-commit-message-撰寫？" class="headerlink" title="為什麼應該要學習更好的 commit message 撰寫？"></a>為什麼應該要學習更好的 commit message 撰寫？</h3><p>第一步，打開手邊的專案並且查看 git log。<br>我相信絕大多數的人，肯定看不懂六個月前自己的 commit 到底對哪裡進行調整、原因是為什麼。</p><p>在你的 Coding 生涯中，或多或少有遇過沒有程式碼註解、沒有文件、沒有可追溯的歷史紀錄，這個時候你就必須要花上多幾倍的時間成本來完成原本的需求，又或者出現類似這樣的問題：我如果刪除了這一行會不會讓程式不會跑？</p><h3 id="展望未來"><a href="#展望未來" class="headerlink" title="展望未來"></a>展望未來</h3><p>撰寫優秀的 Commit，就是節省了你或者你的同事未來尋找 bug 的時間。在開發之餘，花點時間去寫一封提交訊息給未來的自己，是非常值得的，尤其在大型的專案中，任何有關的文件都至關重要。</p><p>我強烈建議，在開發團隊中，如果還沒有建立起提交訊息的相關規範，就立即行動吧！</p><h3 id="比起你做了什麼，別人更想知道你為什麼做"><a href="#比起你做了什麼，別人更想知道你為什麼做" class="headerlink" title="比起你做了什麼，別人更想知道你為什麼做"></a>比起你做了什麼，別人更想知道你為什麼做</h3><p>這句話，是我有一天滑手機時無意間看到的，但印象很深刻。<br>你做了什麼，只要看 changed files 就可以知道了，而你因為什麼而做卻看不出來。<br>如果你要寫 message 時，不妨這樣思考，會有幫助的。</p><h2 id="幾個要點寫出好的提交訊息"><a href="#幾個要點寫出好的提交訊息" class="headerlink" title="幾個要點寫出好的提交訊息"></a>幾個要點寫出好的提交訊息</h2><ol><li>Commit type: 使用特定的類型來表示，可以讓人第一眼就分辨出這是什麼樣類別的提交。</li><li>Length: 適當的長度會讓人感覺到用字精準，通常第一行不會超過 20 個字，並且不會使用標點符號及大寫字母，內容限制在 72 個字。</li><li>Content: 所有的句子都要直接，盡量避免使用太多的連接詞，例如：雖然、也許、我認為、有點…</li></ol><p>知道規範後，要如何生產出內容呢？問自己以下幾個問題，並串接起來，就會豁然開朗：</p><ul><li>我為什麼要做這個變更？</li><li>我做的這些改變會有什麼影響？</li><li>為什麼需要做這些改變？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;add margin&#x27;</span><br><span class="line"></span><br><span class="line">git commit -m &#x27;add margin to product items to prevent them from overlapping&#x27;</span><br></pre></td></tr></table></figure><p>這邊偷偷透露，我以前真的都寫第一種的提交訊息 😂</p><h2 id="常用的-Commit-Type"><a href="#常用的-Commit-Type" class="headerlink" title="常用的 Commit Type"></a>常用的 Commit Type</h2><img src="/posts/Git-commitMessage/gitMessage2.webp" class=""><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>撰寫出色的提交，能幫助整個團隊的溝通及協作。Commit message 是專案的修改歷史，幫助我們解讀過去並在未來做出合理的決定。<br>希望閱讀完本篇的你，有被幫助提升 Commit 的品質。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;以前在開發的時候，總覺得沒有人會去看 git commit 的訊息，所以總是想寫什麼就寫什麼。&lt;br&gt;雖然都會標記一下[類型]：新增功能、刪除…之類的，但是真的超陽春。&lt;br&gt;直到最近，開始幫人家 Review code，才渴望人家的 Commit Message 可以留完整一點給我！&lt;/p&gt;
&lt;p&gt;真心建議大家，早點培養起 commit message 良好習慣就越好！&lt;/p&gt;
&lt;img src=&quot;/posts/Git-commitMessage/gitMessage1.jpeg&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://colinchiu87.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>震驚！使用這一個方法解放你的手機容量 - iCloud 共享相簿</title>
    <link href="https://colinchiu87.github.io/posts/Iphone-sharedAlbum/"/>
    <id>https://colinchiu87.github.io/posts/Iphone-sharedAlbum/</id>
    <published>2024-05-26T03:06:25.000Z</published>
    <updated>2024-05-26T10:03:22.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本想學一下現在的新聞聳動標題，但這樣怎麼 SEO 拉 🤣<br>你是不是每隔一段時間就會收到手機容量快滿的通知？<br>現在手機的容量根本就滿足不了我們小網美，就只能準備一顆硬碟或者訂閱雲端容量。<br>我在這邊正式宣布果粉有福了(<del>功能早就出了</del></p><img src="/posts/Iphone-sharedAlbum/sharedAlbum12.png" class=""><span id="more"></span><h2 id="iCloud-共享相簿"><a href="#iCloud-共享相簿" class="headerlink" title="iCloud 共享相簿"></a>iCloud 共享相簿</h2><p>如其名，一個可以跟其他人一起共同編輯的相簿。在 iCloud 上建立，可以隨時隨地上傳和查看，而且還++不會占用的你任何儲存空間++(❌iCloud❌ 手機容量)，最後還能控制誰可查看或下載。</p><h3 id="如何建立-iCloud-共享相簿？"><a href="#如何建立-iCloud-共享相簿？" class="headerlink" title="如何建立 iCloud 共享相簿？"></a>如何建立 iCloud 共享相簿？</h3><ol><li>確認自己的 Iphone 有沒有開啟該功能。</li></ol><img src="/posts/Iphone-sharedAlbum/sharedAlbum1.png" class=""><ol start="2"><li>建立一個共享相簿，並加入要分享的照片 or 影片。</li></ol><img src="/posts/Iphone-sharedAlbum/sharedAlbum2.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum3.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum4.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum5.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum6.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum7.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum8.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum9.jpg" class=""><ol start="3"><li>邀請朋友、家人訂閱相簿。</li></ol><img src="/posts/Iphone-sharedAlbum/sharedAlbum10.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum11.jpg" class=""><h3 id="有甚麼限制嗎？"><a href="#有甚麼限制嗎？" class="headerlink" title="有甚麼限制嗎？"></a>有甚麼限制嗎？</h3><p>雖然這些相簿不會計入你的 iCloud 儲存空間，但你可以共享的照片及影片、邀請都有數量的限制。</p><ul><li><p>單一協作人每小時上傳到所有共享相簿中的照片和影片數量上限：1000</p></li><li><p>單一協作人每天上傳到所有共享相簿中的照片和影片數量上限：10,000</p></li><li><p>持有人可分享的共享相簿數量上限：200</p></li><li><p>使用者可訂閱的共享相簿數量上限：200</p></li><li><p>每個共享相簿的訂閱者數量上限：100（每個共享相簿的訂閱者數量）</p></li><li><p>任一共享相簿中所有提供者的照片和影片總數上限：5000</p></li><li><p>共享相簿中每張照片或每部影片的評論數量上限：200（評論可以是喜歡或文字項目）</p></li><li><p>每則評論的字元數上限：1024</p></li><li><p>共享相簿持有人每天可傳送的邀請數量上限：200</p></li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這樣一個分享照片的空間，已經算是非常足夠我們平民老百姓使用了，甚至還可以點讚、評論 XD<br>只是在最後提醒一下各位，盡量不要使用共享相簿當成你自己的資料備份，還是有機會會憑空消失的，當然不重要的資料就直接解放你設備的空間吧！<br>希望大家喜歡這次的分享，我們下次見 ☺</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>圖片皆取自 Google<br><span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS96aC10dy8xMDgzMTQ=">Apple官方連結 - 共享相簿<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本想學一下現在的新聞聳動標題，但這樣怎麼 SEO 拉 🤣&lt;br&gt;你是不是每隔一段時間就會收到手機容量快滿的通知？&lt;br&gt;現在手機的容量根本就滿足不了我們小網美，就只能準備一顆硬碟或者訂閱雲端容量。&lt;br&gt;我在這邊正式宣布果粉有福了(&lt;del&gt;功能早就出了&lt;/del&gt;&lt;/p&gt;
&lt;img src=&quot;/posts/Iphone-sharedAlbum/sharedAlbum12.png&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="IPhone" scheme="https://colinchiu87.github.io/tags/IPhone/"/>
    
  </entry>
  
  <entry>
    <title>敏捷式開發真的這麼棒？</title>
    <link href="https://colinchiu87.github.io/posts/Other-agile/"/>
    <id>https://colinchiu87.github.io/posts/Other-agile/</id>
    <published>2024-03-09T06:23:02.000Z</published>
    <updated>2024-03-09T06:55:24.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在正式開始之前，我們先知道什麼是【瀑布式開發】，這也是一般專案團隊最常用的開發方式。</p><img src="/posts/Other-agile/agile1.png" class=""><p>如圖所示，每隔階段定義的十分清楚，要執行的項目明確。就像瀑布一樣，一路向下前行。實際在開發的時候，成員也都樂於這樣的模式，因為不會遇到模糊不清的時候(Ex 需求不知道是什麼就要進行開發… &#x3D; &#x3D;)。這在專案管理上是相對容易的，過程不會遲疑，檢視最後的成果是不是有達成目標就行。</p><span id="more"></span><p>但是，弊端也顯而易見。執行專案時，總是會有意外、風險、市場變化…，這些都是不可被預測的，而當專案是瀑布式開發，對於以上的變因，應對過慢，就很容易導致專案失敗！</p><blockquote><p>瀑布式開發，強調的是「工具」、「流程」。<br>敏捷式開發，強調的是「個人」、「互動」、「變化」。</p></blockquote><h2 id="敏捷式開發"><a href="#敏捷式開發" class="headerlink" title="敏捷式開發"></a>敏捷式開發</h2><h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p><span class="exturl" data-url="aHR0cHM6Ly9hZ2lsZW1hbmlmZXN0by5vcmcvaXNvL3poY2h0L21hbmlmZXN0by5odG1s">《敏捷軟體開發宣言》<i class="fa fa-external-link-alt"></i></span> 裡頭說：</p><ul><li><strong>個人與互動</strong> 重於 流程與工具</li><li><strong>可用的軟體</strong> 重於 詳盡的文件</li><li><strong>與客戶合作</strong> 重於 合約協商</li><li><strong>回應變化</strong> 重於 遵循計畫</li></ul><p>從中知道，敏捷式開發注重的是溝通、成果、合作與變化。</p><blockquote><p>「變」是唯一不變的事情</p></blockquote><h3 id="Scrum框架"><a href="#Scrum框架" class="headerlink" title="Scrum框架"></a>Scrum框架</h3><p>我們耳熟能詳的 Scrum 就是實現敏捷開發的其中一種方式，也是最被廣泛運用的框架。</p><p>為達到相對短的開發週期，可能會抓大概 2 - 4 周，依據產品和團隊的不同，週期也會不同。而這個週期稱之為「Sprint」。</p><p>每一個 Sprint 中，會有四個會議：</p><ol><li>規劃：決定要完成哪些項目</li><li>每日站立：每日花費10-15mins 同步資訊 (昨日完成、今日預計完成、是否遇到阻礙)</li><li>審查：展示成果，取得回饋、新需求</li><li>回顧：回顧衝刺的過程，是否有地方要改進</li></ol><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3> <img src="/posts/Other-agile/agile2.png" class=""><ul><li>產品負責人 (Product Owner)<br>代表客戶的意願，並確保團隊在做從業務角度來說正確的事情。編寫 User story，排出優先級，並放入 代辦清單(backlog)。他決定每一次 sprint 要完成哪些任務，讓整個團隊價值最大化。監督開發的節奏，從而保障產品的品質。</li></ul> <img src="/posts/Other-agile/agile3.png" class=""><ul><li>Scrum主管 (Scrum Master)<br>主要的工作是去除影響團隊達成 sprint 目標的障礙，是規則的執行者。</li></ul> <img src="/posts/Other-agile/agile4.png" class=""><ul><li>開發團隊 (Dev Team)<br>負責交付產品的團隊。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>沒有一定比較好的 development，還是要依照專案需求、公司文化…來做選擇。各有各的優勢在，不過在快速變化的商業環境和技術環境中，迎接變化能力強的敏捷式開發原則，的確是可以滿足現況。<br>祝福大家都不要碰到四不像的敏捷開發😆</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在正式開始之前，我們先知道什麼是【瀑布式開發】，這也是一般專案團隊最常用的開發方式。&lt;/p&gt;
&lt;img src=&quot;/posts/Other-agile/agile1.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;如圖所示，每隔階段定義的十分清楚，要執行的項目明確。就像瀑布一樣，一路向下前行。實際在開發的時候，成員也都樂於這樣的模式，因為不會遇到模糊不清的時候(Ex 需求不知道是什麼就要進行開發… &amp;#x3D; &amp;#x3D;)。這在專案管理上是相對容易的，過程不會遲疑，檢視最後的成果是不是有達成目標就行。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Agile Development" scheme="https://colinchiu87.github.io/tags/Agile-Development/"/>
    
  </entry>
  
  <entry>
    <title>Day.js 將取代 Moment.js？</title>
    <link href="https://colinchiu87.github.io/posts/Js-dayjs/"/>
    <id>https://colinchiu87.github.io/posts/Js-dayjs/</id>
    <published>2024-03-09T05:42:39.000Z</published>
    <updated>2024-03-09T06:05:43.673Z</updated>
    
    <content type="html"><![CDATA[<img src="/posts/Js-dayjs/dayjs-logo.png" class=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開發專案的時候，遇到與時間有關的地方，你會想到甚麼語法？套件？<br>不得不承認，我浮現在腦袋的第一個東西就是 moment.js 的套件，你是不是也是這樣XD<br>它是最古老、最受歡迎的 Library ，在關鍵字搜尋也是優先會看到的。</p><p>但，<em>如果遲遲不放下過去，就抵達不了未來</em>。</p><span id="more"></span><h2 id="比較"><a href="#比較" class="headerlink" title="比較"></a>比較</h2><p>這邊就直接暴雷，告訴大家為什麼可以考慮使用 Day.js。</p><ul><li>Package 輕量：為了不要跟原生 Date 比起來造成太大負擔，走一個輕薄短小的風格，可以引入基本核心的功能，額外的功能再搭配 plugins 處理。</li><li>Api 淺顯易懂：因為都是返回 Day.js 物件，因此可以串接(<strong>chainable</strong>)</li><li>Immutable：每個 API 都回傳全新的 Day.js 物件，而非修改物件本身，避免 side effect 造成 bug</li></ul><img src="/posts/Js-dayjs/img1.webp" class=""><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>你也不要覺得替換一個習慣是個很麻煩的事，因為！</p><p><strong>使用方法幾乎都是和 momentJs 相同的</strong></p><p>最後，DayJs 還有許多客製化和 i18n 的用法，就讓大家去摸索吧！</p><p><span class="exturl" data-url="aHR0cHM6Ly9kYXkuanMub3JnL2VuLw==">官方文件ㄉ連結<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/posts/Js-dayjs/dayjs-logo.png&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在開發專案的時候，遇到與時間有關的地方，你會想到甚麼語法？套件？&lt;br&gt;不得不承認，我浮現在腦袋的第一個東西就是 moment.js 的套件，你是不是也是這樣XD&lt;br&gt;它是最古老、最受歡迎的 Library ，在關鍵字搜尋也是優先會看到的。&lt;/p&gt;
&lt;p&gt;但，&lt;em&gt;如果遲遲不放下過去，就抵達不了未來&lt;/em&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
    <category term="Library" scheme="https://colinchiu87.github.io/tags/Library/"/>
    
  </entry>
  
  <entry>
    <title>動態規劃 Dynamic Programming</title>
    <link href="https://colinchiu87.github.io/posts/Algorithm-dynamicProgramming/"/>
    <id>https://colinchiu87.github.io/posts/Algorithm-dynamicProgramming/</id>
    <published>2023-08-29T11:21:09.000Z</published>
    <updated>2024-03-09T05:41:07.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小明是一名熱愛解決難題的大學生，他正在參加一個程式比賽。這次比賽有一道題目是關於動態規劃法的，要求參賽者找到一個數列中最大的連續子數列和。</p><img src="/posts/Algorithm-dynamicProgramming/img2.jpeg" class=""><span id="more"></span><h2 id="動態規劃法"><a href="#動態規劃法" class="headerlink" title="動態規劃法"></a>動態規劃法</h2><p>這邊先記幾個關鍵字 “儲存”,”小問題”,”組合”,”大問題”。所以基本上一個問題假如能符合以下就可以使用動態規劃來思考。</p><ul><li>可以拆成很多小問題</li><li>答案可以透過組合小問題來解</li><li>小問題重覆量很高</li></ul><img src="/posts/Algorithm-dynamicProgramming/img3.webp" class=""><img src="/posts/Algorithm-dynamicProgramming/img4.webp" class=""><p>我個人研究出當有提到 <code>subarray</code>、<code>subsequence</code> 的時候也可能會使用到動態規劃。</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>就延續前言的故事，來解最大子數列和吧！<br>稍微說明一下題目：在一維的數列中，要找出連續的子數列，且該子數列的和是最大。</p><p><code>array = [−2, 1, −3, 4, −1, 2, 1, −5, 4]</code></p><h4 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h4><p>最直覺的做法，就是直接寫一個雙層迴圈，跑完所有子數列，比較總和大小，就得出答案了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMaxSubarray</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> finalMax = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;array.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j&lt;array.<span class="property">length</span>; j++)&#123;</span><br><span class="line">      currentMax +=  array[j];</span><br><span class="line">      <span class="keyword">if</span> (currentMax &gt; finalMax) &#123;</span><br><span class="line">        finalMax = currentMax;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalMax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，也附上 Wiki 的網址可以參考 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JTkwJUU2JUIzJUEyJUU5JTgyJUEzJUU1JUE1JTkxJUU2JTk1JUIw">連結在此<i class="fa fa-external-link-alt"></i></span></p><h2 id="與貪婪演算法"><a href="#與貪婪演算法" class="headerlink" title="與貪婪演算法"></a>與貪婪演算法</h2><p>總的來說，貪婪演算法和動態規劃算法都是求解最優化問題的重要算法。選擇哪種算法取決於問題的性質和細節，以及算法的效率和準確性要求。對於某些問題，貪婪演算法可能會得到次優解或不可行解，而動態規劃算法可以得到最優解；但是對於某些問題，貪婪演算法的效率更高，而動態規劃算法需要額外的空間和時間來求解。因此，在選擇算法時，需要根據問題的特點和要求來選擇適合的算法。</p><h2 id="有關動態規劃的題目"><a href="#有關動態規劃的題目" class="headerlink" title="有關動態規劃的題目"></a>有關動態規劃的題目</h2><ul><li>斐波那契數列</li><li>連續子數列最大和 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheQ==">Leet Code 53<i class="fa fa-external-link-alt"></i></span></li><li>連續子數列最大乘積 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1wcm9kdWN0LXN1YmFycmF5">Leet Code 152<i class="fa fa-external-link-alt"></i></span></li><li>最長遞增子數列 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2U=">Leet Code 1143<i class="fa fa-external-link-alt"></i></span></li><li>數組數列中，最長子數列 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGlzdGluY3Qtc3Vic2VxdWVuY2Vz">Leet Code 115<i class="fa fa-external-link-alt"></i></span></li></ul><blockquote><p>以上圖片下載自google</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;小明是一名熱愛解決難題的大學生，他正在參加一個程式比賽。這次比賽有一道題目是關於動態規劃法的，要求參賽者找到一個數列中最大的連續子數列和。&lt;/p&gt;
&lt;img src=&quot;/posts/Algorithm-dynamicProgramming/img2.jpeg&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="Algorithm" scheme="https://colinchiu87.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>『小技巧』VSCode 多開視窗（同專案）</title>
    <link href="https://colinchiu87.github.io/posts/Skill-VSCode-multipleWindow/"/>
    <id>https://colinchiu87.github.io/posts/Skill-VSCode-multipleWindow/</id>
    <published>2023-08-22T11:13:29.000Z</published>
    <updated>2024-05-26T04:12:39.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>麥可是一名富有創造力的工程師，他在一家科技公司工作，負責設計和開發新的產品原型。為了更有效地實現他的構想，他在自己的工作站上安裝了多個顯示器。這些螢幕允許他同時查看複雜的設計圖紙、程式碼和模擬結果，使他能夠快速地在不同的任務之間切換，並保持專注。</p><img src="/posts/Skill-VSCode-multipleWindow/img1.jpeg" class=""><span id="more"></span><h2 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h2><p>你也想要成為一位效率爆表的工程師嗎？</p><ol><li>打開你的 VSCode</li><li>Ctrl + Shift + P 開啟指令區 (masOS: Command + Shift + P)<img src="/posts/Skill-VSCode-multipleWindow/img2.png" class=""></li><li>輸入 <code>Workspace: Duplicate As Workspace in New Window</code></li></ol><p>恭喜你又變強了一點點。XD</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;麥可是一名富有創造力的工程師，他在一家科技公司工作，負責設計和開發新的產品原型。為了更有效地實現他的構想，他在自己的工作站上安裝了多個顯示器。這些螢幕允許他同時查看複雜的設計圖紙、程式碼和模擬結果，使他能夠快速地在不同的任務之間切換，並保持專注。&lt;/p&gt;
&lt;img src=&quot;/posts/Skill-VSCode-multipleWindow/img1.jpeg&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="VS Code" scheme="https://colinchiu87.github.io/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>貪婪演算法 Greedy Algorithm</title>
    <link href="https://colinchiu87.github.io/posts/Algorithm-greedy/"/>
    <id>https://colinchiu87.github.io/posts/Algorithm-greedy/</id>
    <published>2023-08-21T11:10:44.000Z</published>
    <updated>2023-08-29T11:21:20.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從前有個小村莊，村民們過著平靜而樸實的生活。然而，他們面臨一個困境：村莊周圍的土地資源有限，每位村民都想要在這些土地上種植作物和建造房屋。因此，土地的分配成了一個問題。</p><p>村莊的首領考慮到了這個問題，他決定請來了一位聰明的專家幫助他們找到一個公平的土地分配方案。這位專家告訴首領，他可以使用一種叫做「貪婪演算法」的方法來解決這個問題。</p><img src="/posts/Algorithm-greedy/img1.avif" class=""><span id="more"></span><h2 id="貪婪演算法"><a href="#貪婪演算法" class="headerlink" title="貪婪演算法"></a>貪婪演算法</h2><p>貪婪演算法（Greedy Algorithm）是一種求解最優化問題的方法，該方法在每一個步驟都選擇當前狀態下的最佳解，並希望通過這種方式最終能夠獲得全局最優解。</p><p>貪婪演算法通常用於求解最優化問題，例如最小生成樹、最短路徑、背包問題等。這些問題可以被描述為一個圖，其中節點代表問題中的元素，邊代表元素之間的關係，權重代表成本或價值。</p><p>貪婪演算法的核心思想是在每個步驟中選擇當前狀態下最佳的解決方案。貪婪演算法不考慮整體最優解，而是通過局部最優解的選擇，希望最終能夠獲得全局最優解。貪婪演算法通常比較簡單且高效，但不能保證一定能獲得最優解。</p><p>那麼回到前言所提的例子，專家建議首領這樣做：首先，從村莊周圍的土地中選擇一塊最大的空地，讓第一位村民在那裡種植作物。然後，在剩餘的土地中，再選擇下一塊最大的空地，讓第二位村民使用，以此類推，直到所有的村民都分到土地為止。</p><h2 id="可能引發的問題"><a href="#可能引發的問題" class="headerlink" title="可能引發的問題"></a>可能引發的問題</h2><p>聽取了專家的建議，開始實施這個方案。一開始，村民們對這種分配方法感到滿意，因為每個人都能獲得相對寬敞的土地。然而，隨著時間的推移，一些村民開始注意到一個問題：雖然他們每個人都有了自己的土地，但其中一些土地可能位於較遠的地點，不太適合種植作物，或者地勢較差。於是，他們開始嘗試交換土地，希望找到更好的選擇。</p><h2 id="零錢問題"><a href="#零錢問題" class="headerlink" title="零錢問題"></a>零錢問題</h2><img src="/posts/Algorithm-greedy/img3.png" class=""><p>像是這類可以利益最大化或是最佳解的的問題很常出現在日常生活中，畢竟大多時候人都是以利益最大化為出發點，思考著該怎麼做才會是最有利的，仔細想想，其實以人類的本性來說，無形之中我們應該用過不少次貪婪演算法了吧！</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>雖然貪婪演算法可以在短期內找到看似最佳的選擇，但它有時會忽略全局的信息，導致最終結果可能不盡如人意。<br>這個故事告訴我們，在解決問題時，我們需要考慮長遠的影響和全局的因素，而不僅僅是眼前的表面利益。</p><img src="/posts/Algorithm-greedy/img2.jfif" class="">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;從前有個小村莊，村民們過著平靜而樸實的生活。然而，他們面臨一個困境：村莊周圍的土地資源有限，每位村民都想要在這些土地上種植作物和建造房屋。因此，土地的分配成了一個問題。&lt;/p&gt;
&lt;p&gt;村莊的首領考慮到了這個問題，他決定請來了一位聰明的專家幫助他們找到一個公平的土地分配方案。這位專家告訴首領，他可以使用一種叫做「貪婪演算法」的方法來解決這個問題。&lt;/p&gt;
&lt;img src=&quot;/posts/Algorithm-greedy/img1.avif&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="Algorithm" scheme="https://colinchiu87.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』圖形 Graph</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-graph/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-graph/</id>
    <published>2023-07-17T13:15:14.000Z</published>
    <updated>2023-08-21T11:10:56.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好～ 在文章開始之前，我們先讓各位看一下名詞提要。</p><ul><li>頂點 Vertex or Node</li><li>邊 Edge：兩個頂點間的連線</li><li>無向性 Undirected：邊無方向性，表示兩點之間為雙向關係。 &#x2F; 有向性 Directed：邊有方向性，表示兩點之間為單向關係。</li><li>加權 Weighted：邊加上權重，代表兩點之間的關係；點加上權重，代表狀態</li></ul><p>以上都是我們在圖形這個章節會時常看到的名詞，那我們正是開始囉 GoGo。</p><span id="more"></span><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>無向圖<img src="/posts/DataStructure-graph/graph1.png" class=""></li><li>有向圖<img src="/posts/DataStructure-graph/graph2.png" class=""></li><li>權重圖<img src="/posts/DataStructure-graph/graph3.png" class=""></li></ol><h2 id="圖形遍歷-Graph-Traversal"><a href="#圖形遍歷-Graph-Traversal" class="headerlink" title="圖形遍歷 Graph Traversal"></a>圖形遍歷 Graph Traversal</h2><h3 id="廣度搜尋-Breadth-First-Search"><a href="#廣度搜尋-Breadth-First-Search" class="headerlink" title="廣度搜尋 Breadth First Search"></a>廣度搜尋 Breadth First Search</h3><p>廣度優先的搜尋順序會是先走訪相鄰節點，都走訪完了，就往下一層繼續走訪，廣度優先搜尋採用queue來實作，因為queue具有先進先出的特性，可以確保先搜尋到的節點，會優先成為下一個搜尋起點。</p><img src="/posts/DataStructure-graph/graph4.png" class=""><p>程式範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnweightedGraph</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">neighbors</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">visited</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addNeighbor</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">neighbors</span>.<span class="title function_">push</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> B = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> C = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> D = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> E = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;E&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> F = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;F&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> G = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;G&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> H = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">A.<span class="title function_">addNeighbor</span>(B);</span><br><span class="line">A.<span class="title function_">addNeighbor</span>(C);</span><br><span class="line">A.<span class="title function_">addNeighbor</span>(D);</span><br><span class="line">B.<span class="title function_">addNeighbor</span>(E);</span><br><span class="line">B.<span class="title function_">addNeighbor</span>(F);</span><br><span class="line">D.<span class="title function_">addNeighbor</span>(G);</span><br><span class="line">D.<span class="title function_">addNeighbor</span>(H);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">BFS</span> = (<span class="params">starter</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> queue = [],</span><br><span class="line">    result = [];</span><br><span class="line">  queue.<span class="title function_">push</span>(starter);</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> firstNode = queue.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="keyword">if</span> (!firstNode.<span class="property">visited</span>) &#123;</span><br><span class="line">    firstNode.<span class="property">visited</span> = <span class="literal">true</span>;</span><br><span class="line">        result.<span class="title function_">push</span>(firstNode.<span class="property">value</span>);</span><br><span class="line">        firstNode.<span class="property">neighbors</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!element.<span class="property">visited</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">BFS</span>(A);</span><br><span class="line"><span class="comment">//輸出結果 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="深度搜尋-Depth-First-Search"><a href="#深度搜尋-Depth-First-Search" class="headerlink" title="深度搜尋 Depth First Search"></a>深度搜尋 Depth First Search</h3><p>會先從一邊開始走訪，概念類似於走迷宮摸著牆走的概念，走到底了就折返，繼續往沒走過的節點探索</p><img src="/posts/DataStructure-graph/graph5.png" class=""><p>程式範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">DFT</span> = (<span class="params">starter</span>) =&gt; &#123;</span><br><span class="line">    starter.<span class="property">visited</span> = <span class="literal">true</span>;</span><br><span class="line">    result.<span class="title function_">push</span>(starter.<span class="property">value</span>);</span><br><span class="line">    starter.<span class="property">neighbors</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!element.<span class="property">visited</span>) <span class="title function_">DFT</span>(element);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">DFT</span>(A);</span><br><span class="line"></span><br><span class="line"><span class="comment">//輸出結果 [&quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;F&quot;, &quot;C&quot;, &quot;D&quot;, &quot;G&quot;, &quot;H&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="最短距離"><a href="#最短距離" class="headerlink" title="最短距離"></a>最短距離</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0B5aW5pbmcxMjA0LyVFNiVCQyU5NCVFNyVBRSU5NyVFNiVCMyU5NSVFNSU5QyU5NiVFOSU5MSU5MSVFOCVBRSU4MCVFNiU5QiVCOCVFNyVBRCU4NiVFOCVBOCU5OC0lRTclQUMlQUMlRTglODIlODYlRTclQUIlQTAtJUU1JTlDJTk2JUU1JUJEJUEyJUU2JTkwJTlDJUU1JUIwJThCLSVFNCVCOCVBRC02MWU5MTkwMzI5ZTA=">延伸一<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BhbWJlci5mcmFnbWVudHMvJUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1LSVFNSVBRCVCOCVFNyVCRiU5MiVFNyVBRCU4NiVFOCVBOCU5OC0xNC1kaWprc3RyYS1hbGdvcml0aG0tJUU2JTlDJTgwJUU3JTlGJUFEJUU4JUI3JUFGJUU1JUJFJTkxJUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1LTc0NTk4M2RkNDMzMg==">延伸二<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvYmVsbG1hbi1mb3JkLWFsZ29yaXRobS1kcC0yMy8=">延伸三<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大家好～ 在文章開始之前，我們先讓各位看一下名詞提要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂點 Vertex or Node&lt;/li&gt;
&lt;li&gt;邊 Edge：兩個頂點間的連線&lt;/li&gt;
&lt;li&gt;無向性 Undirected：邊無方向性，表示兩點之間為雙向關係。 &amp;#x2F; 有向性 Directed：邊有方向性，表示兩點之間為單向關係。&lt;/li&gt;
&lt;li&gt;加權 Weighted：邊加上權重，代表兩點之間的關係；點加上權重，代表狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上都是我們在圖形這個章節會時常看到的名詞，那我們正是開始囉 GoGo。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』字典和雜湊表 Dictionary and HashMap</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-dictionaryAndHashmap/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-dictionaryAndHashmap/</id>
    <published>2023-06-25T11:36:15.000Z</published>
    <updated>2023-07-17T12:48:38.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中的字典和雜湊表是非常有用的資料結構，可以用來快速查找鍵值對應的值。在 JavaScript 中，字典通常是用物件來實現，而雜湊表則可以使用 Map 來實現。這些資料結構非常常見，因此學習如何使用它們是很重要的。</p><p>順道提一下，集合(Set) [值：值]所關注的是值的本體，而字典(Dictionary)、雜湊表(HashMap) [鍵：值]關注的是兩者的 Mapping 關聯，這樣就可以簡單區分開來了。</p><p>在本篇文章中，我們將介紹如何在 JavaScript 中使用字典和雜湊表。我們將會討論它們的特性、如何使用它們來解決問題，以及它們的複雜度和效能。如果你對 JavaScript 的資料結構和算法感到興趣，這篇文章將會對你有所幫助。</p><span id="more"></span><h2 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 Dictionary"></a>字典 Dictionary</h2><p>想必大家都已經知道，集合代表的是一組互不重複的元素。在字典中，儲存的是「鍵：值」，鍵名用來查詢特定元素。<br>也稱作映射。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>set(key, value): 添加新的元素。</li><li>remove(key): 移除對應鍵值的元素。</li><li>has(key): 如果該鍵值存在此字典中，則回傳 true; 反之，回傳 false。</li><li>get(key): 利用鍵值尋找特定數值並回傳。</li><li>clear(): 清空此字典的所有元素。</li><li>size(): 返回字典所含的元素數量。</li><li>keys(): 回傳一個陣列，包含所有鍵。</li><li>values(): 回傳一個陣列，包含所有值。</li></ul><h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p>這次實作的類別是以 ECMAScript 6 中的 Map 做基礎。會明顯的發現和 Set 類別雷同。</p><h4 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dictionary</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="has-set"><a href="#has-set" class="headerlink" title="has, set"></a>has, set</h4><p>第一步先建立 has, set 方法，而這邊會要先做 has()，是因為它會被 set, remove 其他的方法呼叫。<br>而 set(key, value)，可以用來添加一個新的值，或是將原有的值做更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">has</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> items;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">set</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">  items[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(key))&#123;</span><br><span class="line">    <span class="keyword">delete</span> items[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-values"><a href="#get-values" class="headerlink" title="get, values"></a>get, values</h4><p>如果想要在字典搜尋特定的一個元素，就可以使用 get 和 values。<br><code>values() 不能僅僅使用 for-in 遍歷整個 items 物件的屬性，還需要使用 has() 驗證是否包含該屬性。 因為物件的原型會含其它屬性在裡面( Js 基本的物件屬性是會被繼承的，並會存在當前的物件中 )</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> items)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(k))&#123;</span><br><span class="line">      values.<span class="title function_">push</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clear-size-keys-getItems"><a href="#clear-size-keys-getItems" class="headerlink" title="clear, size, keys, getItems"></a>clear, size, keys, getItems</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  items = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">keys</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">getItems</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Dictionary-類別-郵件通訊錄"><a href="#使用-Dictionary-類別-郵件通訊錄" class="headerlink" title="使用 Dictionary 類別 (郵件通訊錄)"></a>使用 Dictionary 類別 (郵件通訊錄)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> <span class="title class_">Dictionary</span>();</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Colin&#x27;</span>, <span class="string">&#x27;colin1225@email.com&#x27;</span>)</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;jake0305@email.com&#x27;</span>)</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Rick&#x27;</span>, <span class="string">&#x27;rick1010@email.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">has</span>(<span class="string">&#x27;Colin&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">size</span>()) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">keys</span>()) <span class="comment">// [&quot;Colin&quot;, &quot;Jake&quot;, &quot;Rick&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">values</span>()) <span class="comment">// [&#x27;colin1225@email.com&#x27;, &#x27;jake0305@email.com&#x27;, &#x27;rick1010@email.com&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">get</span>(<span class="string">&#x27;Rick&#x27;</span>)) <span class="comment">// &#x27;rick1010@email.com&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="雜湊表-HashMap"><a href="#雜湊表-HashMap" class="headerlink" title="雜湊表 HashMap"></a>雜湊表 HashMap</h2><p>HashTable 也稱作 HashMap，是 Dictionary 類別的一種實作方式。<br>使用雜湊演算法是為了更快更精準的在資料中找到一個值。以往我們要在資料結構中獲得一個值，要經過遍歷整個資料集。<br>雜湊讓我們利用函數就能得到資料的具體位置，因而達到快速檢索的效果。</p><p><img src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*0xeEq-iJDrVAU0zG.png" alt="HashMap"></p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li>雜湊函數: 給定一個鍵值，返回值在表中的地址。</li><li>put(key, value): 向雜湊表增加一個新資料。</li><li>remove(key): 根據鍵值從表中移除值。</li><li>get(key): 根據鍵值檢索特定值，返回。</li></ul><h3 id="實作-1"><a href="#實作-1" class="headerlink" title="實作"></a>實作</h3><h4 id="雜湊函數"><a href="#雜湊函數" class="headerlink" title="雜湊函數"></a>雜湊函數</h4><p>順序第一位為雜湊函式，是 HashTable 中一個私有的函數。<br>這邊使用一個最常見的 – 「雙輸」(lose lose)，將每一個鍵值中的每個字母的 ASCII 值相加。<br>在函式的最後常會使用 hash 值和任意數做除法的餘數(mod)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loseloseHashCode = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;key.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    hash += key.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(position + <span class="string">&#x27;-&#x27;</span> + key);</span><br><span class="line">  table[position] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>使用雜湊函式求出 key 值所對應位置，並回傳 position。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> table[<span class="title function_">loseloseHashCode</span>(key)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  table[<span class="title function_">loseloseHashCode</span>(key)] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-HashTable-類別"><a href="#使用-HashTable-類別" class="headerlink" title="使用 HashTable 類別"></a>使用 HashTable 類別</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> <span class="title class_">HashTable</span>()</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Colin&#x27;</span>, <span class="string">&#x27;colin1225@email.com&#x27;</span>)</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;jake0305@email.com&#x27;</span>)</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Rick&#x27;</span>, <span class="string">&#x27;rick1010@email.com&#x27;</span>)</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">  20 - Colin</span></span><br><span class="line"><span class="comment">  9 - Jake</span></span><br><span class="line"><span class="comment">  23 - Rick</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用 get()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Colin&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Eileen&#x27;</span>));</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">  colin1225@eamil.com</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由於 Colin 是存在表中的鍵，所以會返回它的值。但 Eileen 並不在裡面，當我們試著取出值時，回傳將為 undefined（不存在）。<br>如果對 Colin 執行 remove()，那理所當然也會 return undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash.<span class="title function_">remove</span>(<span class="string">&#x27;Colin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Colin&#x27;</span>));</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="雜湊集合"><a href="#雜湊集合" class="headerlink" title="雜湊集合"></a>雜湊集合</h2><p>接著，我們來說明一下『雜湊集合』這個專有名詞。<br>在某些程式語言中，你會發現有這樣的一個實作。我們可以從名稱中了解到這是由集合所構成，但是新增、插入、刪除，是使用雜湊函數。<br>與剛才我們的實作不同之處，不添加「鍵值對」，只插入值。例如存放水果種類，但不賦予它們定義。</p><h2 id="雜湊表的衝突"><a href="#雜湊表的衝突" class="headerlink" title="雜湊表的衝突"></a>雜湊表的衝突</h2><p>有時候，會遇到有相同雜湊值的情況。不同的值在表中相同的位置，稱之為衝突。<br>在正常程式執行的情況下，最後添加的值將會佔據該位置，也就是會覆蓋掉。<br>當然，我們的目的就是要將所有的資料存放進來，這樣的話不就達不到初衷了嗎？</p><h3 id="面對衝突的處理"><a href="#面對衝突的處理" class="headerlink" title="面對衝突的處理"></a>面對衝突的處理</h3><p>在遇到衝突時，有兩個方法：</p><ol><li>Separate Chaining</li><li>Linear Probing</li></ol><h4 id="Separate-Chaining"><a href="#Separate-Chaining" class="headerlink" title="Separate Chaining"></a>Separate Chaining</h4><ul><li>一個(Key)位置允許放入多個值</li><li>每一個位置(Point)都指向一個 Linked List，以存放多個值</li><li>如果一個位置沒有放置任一值，Pointer 會被視為 null</li></ul><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cUZn32yJu7Z-fnDhf1ICMJkZH-tUU_dYd-pxmJ1Wk5tVqLa6cKsJ_xm9zbop5Btzof6I0da_7Z0R9m0Fr-cveDGT6HI360YuNKxQ936-vpEUz1DJefDp8L7vlchhTyS3fAD3Lq5yb8zB4hwOVLSZGt=s480-no?authuser=0" alt="此圖片源自網路"></p><h4 id="Linear-Probing"><a href="#Linear-Probing" class="headerlink" title="Linear Probing"></a>Linear Probing</h4><ul><li>如果該 key 對應的位置已經佔用（衝突），則會存入下一個 point(index+1)。</li><li>can provide high performance because of its good locality of reference</li><li>需要注意的地方就是陣列的空間有機會被使用完。</li></ul><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/2560px-HASHTB12.svg.png" alt="來自wiki"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JavaScript 中的字典和雜湊表是非常有用的資料結構，可以用來快速查找鍵值對應的值。在 JavaScript 中，字典通常是用物件來實現，而雜湊表則可以使用 Map 來實現。這些資料結構非常常見，因此學習如何使用它們是很重要的。&lt;/p&gt;
&lt;p&gt;順道提一下，集合(Set) [值：值]所關注的是值的本體，而字典(Dictionary)、雜湊表(HashMap) [鍵：值]關注的是兩者的 Mapping 關聯，這樣就可以簡單區分開來了。&lt;/p&gt;
&lt;p&gt;在本篇文章中，我們將介紹如何在 JavaScript 中使用字典和雜湊表。我們將會討論它們的特性、如何使用它們來解決問題，以及它們的複雜度和效能。如果你對 JavaScript 的資料結構和算法感到興趣，這篇文章將會對你有所幫助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 LeetCode 技巧 』Prefix Sum 前綴和</title>
    <link href="https://colinchiu87.github.io/posts/Leetcode-prefixSum/"/>
    <id>https://colinchiu87.github.io/posts/Leetcode-prefixSum/</id>
    <published>2023-04-09T07:25:53.000Z</published>
    <updated>2023-06-25T10:58:55.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近開始學習資料結構，搭配著 LeetCode 進行練習，發現有很多解題的觀念都可以通用！<br>這次就來説說這次解到的題目，有錯誤的地方還請多多指教 &gt;_&lt;<br>以下為題目連結：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVtb3ZlLXplcm8tc3VtLWNvbnNlY3V0aXZlLW5vZGVzLWZyb20tbGlua2VkLWxpc3Qv">1171. Remove Zero Sum Consecutive Nodes from Linked List<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h2 id="Prefix-Sum-前綴和"><a href="#Prefix-Sum-前綴和" class="headerlink" title="Prefix Sum 前綴和"></a>Prefix Sum 前綴和</h2><p>什麼是前綴和呢？簡單來說，就是將前面的數相加得到的一個新的和陣列。<br>而得到的新陣列可以讓我們做一些事，求區間和（subarray）就是基礎應用之一。</p><p>當題目是整數列而且出現需要”子數列”或”連續的子數列”時，就能利用這著概念去解題，效果可說是相當不錯。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 取得前綴和，累加 array[0:i-1] 得到 prefixSumArray[i]</span></span><br><span class="line"><span class="keyword">let</span> prefixSumArray = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>];</span><br></pre></td></tr></table></figure><p>在實作上，我們就可以直接使用這個數列進行累加，就不用再去遍歷一次 array。</p><h2 id="解題絲路"><a href="#解題絲路" class="headerlink" title="解題絲路"></a>解題絲路</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>先來看題目~<br>在給定的鏈結裡面，重複扣除總和為 0 的<strong>連續數列</strong>，直到沒有這類的數列為止。<br>最後返回剩餘的鏈結。</p><p>寫之前再到最下面看一下”條件(Constraints)”，這很重要呦！</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>看到”連續數列”，我們就可以試著利用 Prefix Sum。<br>另外補充，一般來說，前綴和會和 Map 一起做使用。</p><ol><li><p>建構一個 MAP 來儲存具有同累加值的最後節點的累積和。<br>因為最後一個節點的下一個數值是我們要建造和連結輸出的地方。</p></li><li><p>將 MAP 給實作出來</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeZeroSumSublists = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 head == false，return head</span></span><br><span class="line">  <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 概念 prefix sum map</span></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">  newNode.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> current = newNode,</span><br><span class="line">    prefixSumMap = <span class="keyword">new</span> <span class="title class_">Map</span>(),</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    sum += current.<span class="property">val</span>;</span><br><span class="line">    prefixSumMap.<span class="title function_">set</span>(sum, current);</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  current = newNode;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    sum += current.<span class="property">val</span>;</span><br><span class="line">    current.<span class="property">next</span> = prefixSumMap.<span class="title function_">get</span>(sum).<span class="property">next</span>;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newNode.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="類似題型"><a href="#類似題型" class="headerlink" title="類似題型"></a>類似題型</h2><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3ViYXJyYXktc3VtLWVxdWFscy1rLw==">560. Subarray Sum Equals K<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1hdmVyYWdlLXN1YmFycmF5LWkv">643. Maximum Average Subarray I<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近開始學習資料結構，搭配著 LeetCode 進行練習，發現有很多解題的觀念都可以通用！&lt;br&gt;這次就來説說這次解到的題目，有錯誤的地方還請多多指教 &amp;gt;_&amp;lt;&lt;br&gt;以下為題目連結：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVtb3ZlLXplcm8tc3VtLWNvbnNlY3V0aXZlLW5vZGVzLWZyb20tbGlua2VkLWxpc3Qv&quot;&gt;1171. Remove Zero Sum Consecutive Nodes from Linked List&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://colinchiu87.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python 分割字串的幾種方式</title>
    <link href="https://colinchiu87.github.io/posts/Python-splitString/"/>
    <id>https://colinchiu87.github.io/posts/Python-splitString/</id>
    <published>2023-02-06T11:00:09.000Z</published>
    <updated>2023-03-21T12:07:32.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做資料處理時，是不是很常遇到要做字串分割的時候呢？<br>這幾天本人剛好有遇到要擷取字串，就想研究一下，到底有哪些方法能滿足我的需求！</p><span id="more"></span><h2 id="擷取字串"><a href="#擷取字串" class="headerlink" title="擷取字串"></a>擷取字串</h2><h3 id="Slicing-分割"><a href="#Slicing-分割" class="headerlink" title="Slicing 分割"></a>Slicing 分割</h3><p>這個方法就像陣列以索引取值一樣，短到字元、長到字段。</p><ul><li>字元<br>語法：字串[索引]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_string = <span class="string">&quot;apple&quot;</span></span><br><span class="line"><span class="built_in">print</span>(some_string[<span class="number">1</span>]) <span class="comment"># &quot;p&quot;</span></span><br></pre></td></tr></table></figure><ul><li>字串中的子字串(substring)<br>語法：字串[起始:結束:間隔]<br>參數介紹：索引值是由計算是由 0 開始，所以起始值要 +1 取值，例如起始值 2 代表要由第 3 個字元開始；結束值要取值時自己不能算。例如結束等於 5，所以取到第 5 個值；間隔值不是必填，預設是 1。起始值不填就代表由最前方開始，結束值如果不填就代表算到底。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&quot;peach&quot;</span></span><br><span class="line"><span class="built_in">print</span>(fruit[<span class="number">2</span>:<span class="number">4</span>]) <span class="comment"># &quot;ac&quot;</span></span><br><span class="line"><span class="built_in">print</span>(fruit[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># &quot;pah&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fruit[::-<span class="number">1</span>]) <span class="comment"># 反轉字串 &quot;hcaep&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Split-分割字串為陣列"><a href="#Split-分割字串為陣列" class="headerlink" title="Split 分割字串為陣列"></a>Split 分割字串為陣列</h3><p>你有時候會遇到資料是利用 “,” “、” “空格” “-“ 等符號來區分每一筆資料。</p><p>這時候就需要把這些字串做處理，讓它變成陣列方便我們使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&quot;apple,banana,peach&quot;</span></span><br><span class="line">data_arr = fruit.split(<span class="string">&quot;,&quot;</span>)  <span class="comment"># - 使用逗號分割</span></span><br><span class="line"><span class="built_in">print</span>(fruit)</span><br><span class="line"><span class="built_in">print</span>(data_arr)  <span class="comment"># - [apple, banana, peach]</span></span><br><span class="line"><span class="built_in">print</span>(data_arr[<span class="number">0</span>])  <span class="comment"># - apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># - 適用任何符號！</span></span><br><span class="line"><span class="comment"># - 多多研究要處理的資料有什麼特性或規律，在處理上能有較好的效率。</span></span><br></pre></td></tr></table></figure><h3 id="Regexes-正規表達式"><a href="#Regexes-正規表達式" class="headerlink" title="Regexes 正規表達式"></a>Regexes 正規表達式</h3><p>又稱作正則表達式。Python 支援的介面存放在 re 的模組裡，所以要使用記得要引用(import re)</p><p>正規表達式是很適合用來匹配字串極好用的工具，有獨立的語法，並能透過特定的語句規則（Pattern），達到搜尋、匹配、替代等等的需求。</p><ul><li><p>reg.split()<br>我們可以編譯一個正則表達式，用它來分割字串，和 python.split 一樣，返回一個包含子字串的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">fruit = <span class="string">&quot;apple banana peach&quot;</span></span><br><span class="line">regex = re.complie(<span class="string">&#x27;\s+&#x27;</span>)  <span class="comment"># - \s 是一個特殊字元，包含所有的空白字元（空白、TAB、換行符號），而＋則代表一個或多個空格。</span></span><br><span class="line">result = regex.split(fruit)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>推薦一個網站，<span class="exturl" data-url="aHR0cHM6Ly9yZWdleDEwMS5jb20v">https://regex101.com/<i class="fa fa-external-link-alt"></i></span>能即時將你輸入的字串比對你的正規表達式語法。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做資料處理時，是不是很常遇到要做字串分割的時候呢？&lt;br&gt;這幾天本人剛好有遇到要擷取字串，就想研究一下，到底有哪些方法能滿足我的需求！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://colinchiu87.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』集合 Set</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-set/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-set/</id>
    <published>2022-11-21T08:07:35.000Z</published>
    <updated>2023-04-09T07:31:51.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這週要帶各位認識的資料結構是「集合 Set」。在深入探索它之前先讓我們看一下他的數學概念，在裡頭集合是一組不同的物件（的集合）。</p><p>比如說，一個由大於或等於零的整數組成的自然數集合：Ｎ &#x3D; {0, 1, 2, 3, 4, 5, …}。集合中的物件列表用{}包圍起來。</p><p>另一個概念為「空集」，不包含任何元素的集合。比如說： 20, 23 這兩個數字之間的質數集合，由於這兩數之間沒有質數（除了 1 和本身，沒有其他正因數的大於一的自然數），這個集合就是空集合。用 { } 表示。個人覺得本章節在資料結構中蠻重要的，特別是對於後端在資料庫存取時常用到這一個概念。</p><span id="more"></span><h2 id="什麼是集合？"><a href="#什麼是集合？" class="headerlink" title="什麼是集合？"></a>什麼是集合？</h2><p>集合是由一組無序且唯一的項目組成的。這個資料結構使用了與有限集合相同的概念，但應用在電腦科學的資料結構中。你也可以把集合想成一個既沒有元素，也沒有順序的陣列。在數學中，集合也有聯集、焦急、差集，在接下來也會一一介紹操作。</p><h2 id="建立一個集合"><a href="#建立一個集合" class="headerlink" title="建立一個集合"></a>建立一個集合</h2><p>在 ES6 中，已經有 Set 的類別，<del>終於遇到原生的資料結構了</del>QAQ<br>不過以下我們還是自己寫一個會比較印象深刻！</p><p>這是我們的 Set 類別骨架：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Set</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡有一個細節，我們使用的不是陣列而是物件，原因是 Java Script 的物件是不允許一個鍵指向兩個不同屬性，保證了元素都是唯一的。</p><p>開始宣告一些集合可用的方法：</p><ul><li>add(value)：向集合添加一個新的項目。</li><li>remove(value)：從一個集合移除一個值。</li><li>has(value)：如果值在集合中，返回 true，反之 false。</li><li>clear()：移除集合中所有項目。</li><li>size()：返回集合所包含元素的數量。與陣列 length 相同。</li><li>values()：返回一個包含集合中所有值的陣列。</li></ul><h3 id="has-value"><a href="#has-value" class="headerlink" title="has(value)"></a>has(value)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">has</span>(value) = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">in</span> items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然我們用物件來存放集合的值，就可以使用 JS 的 in 運算子來驗證是否是物件的屬性。</p><p>&#x3D;&#x3D;補充一個方法 obj.hasOwnProperty(prop)，它會返回一個布林值，指示物件自身屬性中（非繼承屬性）是否具有指定的屬性。&#x3D;&#x3D;</p><h3 id="add-value"><a href="#add-value" class="headerlink" title="add(value)"></a>add(value)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">    items[value] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新增項目時，先檢查它是否存在於集合中。</p><p>&#x3D;&#x3D;添加一個值的時候，把它同時當作鍵和值儲存，因為這樣有利於尋找這個值&#x3D;&#x3D;</p><h3 id="remove-value-clear"><a href="#remove-value-clear" class="headerlink" title="remove(value) &amp; clear()"></a>remove(value) &amp; clear()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">    <span class="keyword">delete</span> items[value];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法中，我們會驗證給定的 value 是否存在於集合中。如果存在，就從集合中移除 value，返回 true，表示值被移除；否則返回 false。</p><p>既然用物件來存放集合的 items 物件，就可以使用 delete 運算子從 items 物件中移除屬性。</p><p>使用 Set 類別的範例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>出於好奇，如果執行以上程式碼之後，在主控台（ console.log ）輸出 items 變數，Google Chrome 就會輸出如下內容：<br>  Object{ 1: 1, 2: 2 }<br>可以看到，這是一個有兩個屬性的物件。屬性名就是添加到集合的值同時它也是屬性值</p></blockquote><p>如果想移除集合中的所有值，可以用 clear 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  items = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要重設 items 物件，需要做的只是把一個空物件重新賦值給它。</p><h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><p>這裡會有三種實作方法。</p><p>第一種是使用一個 length 變數，每當使用 add 或 remove 方法時控制它。</p><p>第二種方法，使用 JavaScript 內建的 Object 類別的一個內建函數（ ECMAScript 5 以上版本 ）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三種方法是手動提取 items 物件的每一個屬性，紀錄屬性的個數並返回這個數字。這可以運行在每個瀏覽器，和之前的程式碼是等價的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">sizeLegacy</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> items)&#123;</span><br><span class="line">    <span class="keyword">if</span>(items.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">      ++count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍歷 items 物件的所有屬性，檢查它們是否是物件本身的屬性。如果是，就遞增 count 值，最後在方法結束再返回這數字。</p><blockquote><p>不能簡單地使用 for-in 語句遍歷 items 物件的屬性，遞增 count 變數的值。還需要使用 has 方法，因為物件的原型包含了額外的屬性。</p></blockquote><h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-Set-類別"><a href="#使用-Set-類別" class="headerlink" title="使用 Set 類別"></a>使用 Set 類別</h3><p>資料結構已經完成囉，看看怎麼使用它吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">// [&quot;1&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">size</span>()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">set.<span class="title function_">remove</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">// [&quot;2&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>對集合可以進行的操作如下：</p><ul><li>聯集：給定的兩集合，返回一個包含兩個集合中所有元素的新集合。</li><li>交集：給定的兩集合，返回一個包含兩個集合中共有元素的新集合。</li><li>差集：給定的兩集合，返回一個包含所有存在於第一個集合且不存在於第二個集合的元素的新集合。</li><li>子集：驗證一個給定集合是否是另一集合的子集。</li></ul><h3 id="聯集"><a href="#聯集" class="headerlink" title="聯集"></a>聯集</h3><p>集合 A 和 B 的聯集，表示為 $ A\bigcup B $ ，定義如下：</p><p>$$ A\bigcup B &#x3D; { x | x \in A \bigvee x \in B } $$</p><p>意思是 x （元素）存在於 A 中，或 x 存在於 B 中。</p><img src="/posts/DataStructure-set/set_union.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">union</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> unionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  values = otherSet.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>意思是 x （元素）存在於 A 中，且 x 存在於 B 中。</p><img src="/posts/DataStructure-set/Set_intersection.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">intersection</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">      intersectionSet.<span class="title function_">add</span>(values.[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>意思是 x （元素）存在於 A 中，且 x 不存在於 B 中。</p><img src="/posts/DataStructure-set/Set_difference.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">difference</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> differenceSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">      differenceSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>意思是集合 A 中的每一個 x （元素），也需要存在於 B 中。</p><img src="/posts/DataStructure-set/subset.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">subset</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>() &gt; otherSet.<span class="title function_">size</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這章學習了如何從頭實作與 ES6 中定義的類似的 Set 類別。我們還介紹了在其他程式語言的集合結構的實作中不常見的一些方法，例如：連擊、交集、差集..等。相較於前幾個主題，我們完成了較完善的實例！給自己一個掌聲 👏🏻</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這週要帶各位認識的資料結構是「集合 Set」。在深入探索它之前先讓我們看一下他的數學概念，在裡頭集合是一組不同的物件（的集合）。&lt;/p&gt;
&lt;p&gt;比如說，一個由大於或等於零的整數組成的自然數集合：Ｎ &amp;#x3D; {0, 1, 2, 3, 4, 5, …}。集合中的物件列表用{}包圍起來。&lt;/p&gt;
&lt;p&gt;另一個概念為「空集」，不包含任何元素的集合。比如說： 20, 23 這兩個數字之間的質數集合，由於這兩數之間沒有質數（除了 1 和本身，沒有其他正因數的大於一的自然數），這個集合就是空集合。用 { } 表示。個人覺得本章節在資料結構中蠻重要的，特別是對於後端在資料庫存取時常用到這一個概念。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』鏈結串列 Linked-List</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-linkedList/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-linkedList/</id>
    <published>2022-11-21T07:36:21.000Z</published>
    <updated>2023-04-09T07:30:54.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這週要帶各位認識的資料結構是「 鏈結串列 Linked-List 」，一開始所學的陣列（串列）是一種非常簡易能讓我們存放資料序列的資料結構，而鏈結串列則是一種動態的，我們進行新增或刪減元素，就會依照需求進行擴充。陣列應該是大家最常用的資料結構，每種語言都支持它，但是卻有一個隱憂：在大多數的語言中，<strong>陣列的大小是固定的</strong>，從起點或中間插入、移除元素是非常耗成本的。</p><span id="more"></span><h2 id="鏈結串列-Linked-List"><a href="#鏈結串列-Linked-List" class="headerlink" title="鏈結串列(Linked-List)"></a>鏈結串列(Linked-List)</h2><p>鏈結串列存放著有序的資料，但與陣列不同的是，其中的元素在記憶體中並不是連續放置的，每個元素是由一個節點和一個指向下一個元素的鏈結組成。</p><p><a href="https://miro.medium.com/max/970/1*ZsQoOXgnSpaEDlUEVOoKgA.png"><img src="https://miro.medium.com/max/970/1*ZsQoOXgnSpaEDlUEVOoKgA.png" alt="鏈結串列"></a></p><h3 id="優劣之處"><a href="#優劣之處" class="headerlink" title="優劣之處"></a>優劣之處</h3><p>優點顯而易見，在我們新增元素或刪除時並不需要去移動其他的元素，只需要注意將鏈結重新調整就好。<br>上帝開了一扇窗給你，就會關你一扇門。<br>你還記得陣列可以隨意存取任何位置的任何元素嗎？而鏈結串列只能從起點也就是 head 開始迭代下去。如果你在考慮要使用陣列還是鏈結串列時，不妨可以針對你的需求來做出較佳的選擇。</p><h3 id="現實中的實例"><a href="#現實中的實例" class="headerlink" title="現實中的實例"></a>現實中的實例</h3><ul><li>尋寶遊戲<br>依照線索一道一道往下解謎。<br><a href="https://www.suloves.com/ckfinder/userfiles/images/depositphotos_10772916-stock-photo-treasure-map.jpg"><img src="https://www.suloves.com/ckfinder/userfiles/images/depositphotos_10772916-stock-photo-treasure-map.jpg" alt="尋寶"></a></li><li>火車<br>由一節一節的車廂連結而成，很容易將其分開。<br><a href="https://taiwan.sharelife.tw/tw-news-img/50859/e277220720385717.jpg"><img src="https://taiwan.sharelife.tw/tw-news-img/50859/e277220720385717.jpg" alt="火車"></a></li></ul><h3 id="建立鏈結串列"><a href="#建立鏈結串列" class="headerlink" title="建立鏈結串列"></a>建立鏈結串列</h3><p>瞭解 Linked-List 後，我們就要用程式來實作啦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向串列尾部添加一個新元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">append</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>)&#123;</span><br><span class="line">      head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 串列迴圈，直到找到最後一個</span></span><br><span class="line">      <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到最後一項，將其 next 指向 node ，建立鏈結</span></span><br><span class="line">      current.<span class="property">next</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length++; <span class="comment">// 更新串列長度</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向串列的特定位置插入一個新元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">position, element</span>)&#123;</span><br><span class="line">    <span class="comment">// 檢查越界值</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">          previous,</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">        node.<span class="property">next</span> = current;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          previous = current;</span><br><span class="line">          current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="property">next</span> = current;</span><br><span class="line">        previous = node;</span><br><span class="line">      &#125;</span><br><span class="line">      length++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 從特定位置移除一項</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">    <span class="comment">// 檢查越界值</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length)&#123;</span><br><span class="line">      <span class="keyword">let</span> current = head,</span><br><span class="line">          previous,</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 移除第一項</span></span><br><span class="line">      <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">        head = current.<span class="property">next</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          previous = current;</span><br><span class="line">          current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 previous 與 current 的下一項鏈結起來：跳過 current ，進而移除它 previous.next = current.next;</span></span><br><span class="line">      &#125;</span><br><span class="line">      length--;</span><br><span class="line">      <span class="keyword">return</span> current.<span class="property">element</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 從串列中移除一項</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回元素在串列中的索引。如果串列中沒有該元素則返回 -1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head,</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">      <span class="keyword">if</span>(element === current.<span class="property">element</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鏈結串列中不含任何元素，返回 true。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回鏈結串列包含的元素個數。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由於使用了 Node 類別，就需要覆寫繼承自 Js 物件預設的方法，讓其只輸出元素的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head,</span><br><span class="line">        string = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">      string += current.<span class="property">element</span>;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linked-List 還需要一個 Node 類別來輔助，表示要加入串列的項目。它包含一個值 (element) ，和 指向串列中下一個節點的指位器 next 屬性。另一個重點是，我們還要一個用來存放第一個節點的引用(head)。</p><h3 id="方法詳述"><a href="#方法詳述" class="headerlink" title="方法詳述"></a>方法詳述</h3><p>相關的程式碼都在上方，這邊就不再多打一次了，我們直接說明邏輯的部份！</p><h4 id="添加：在鏈結串列尾部追加元素"><a href="#添加：在鏈結串列尾部追加元素" class="headerlink" title="添加：在鏈結串列尾部追加元素"></a>添加：在鏈結串列尾部追加元素</h4><p>append(element)，這邊有兩種情況，一是串列為空；二是不為空。</p><ul><li>向空串列添加一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist4.jpg" class=""><p>如果 head 的值為 null，就意味著在向串列添加第一個元素，所以要做的是將 head 指向 node 元素。而 node.next &#x3D;&#x3D; null。</p><ul><li>向一個不為空的串列尾部添加元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist5.jpg" class=""><p>首先，要先找到最後一個元素。<br>⚠️ 要注意的是我們只知道第一個元素，因此需要迴圈存取串列，直到找出最後一個。<br>為此我們要一個變數是指向串列中 current 項目，當 current.next 為 null 時，就知道我們到達串列尾端了。接下來要做的就是讓當前（也就是最後一個）元素的 next 指位器指向想要添加的串列節點上。</p><h4 id="移除：從鏈結串列中移除元素"><a href="#移除：從鏈結串列中移除元素" class="headerlink" title="移除：從鏈結串列中移除元素"></a>移除：從鏈結串列中移除元素</h4><p>removeAt(position)，該方法要得到移除元素的位置，就需要先驗證這個位置是有效的。從 0 到串列長度都是有效位置。如果不是有效，就 return null（意即沒從串列移除元素）。</p><p>兩種情況：一是移除第一個元素；二是移除第一個以外的任意元素。</p><ul><li>從串列中移除第一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist6.jpg" class=""><p>要做的是讓 head 指向串列第二個元素。我們將用 current 變數建立一個對串列中第一個元素引用。將 head 賦為 current.next，就完成了。</p><ul><li>從串列中移除中間元素</li></ul><p>需要依靠一個細節迭代串列，直到到達目標位置（使用一個用於內部控制和遞增的 index 變數）：current 變數總是為對串列迴圈的當前元素的引用；他被命名為 previous。</p><p>因此，要從串列中移除當前元素，要做的就是將 previous.next 和 current.next 鏈結起來。這樣當前元素就會被丟棄在電腦記憶體中，等著被垃圾回收桶清除。</p><ul><li>從串列中移除最後一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist7.jpg" class=""><p>當我們跳出迴圈，current 是對串列中最後一個元素（要移除的項目），current.next 為 null（因為他是最後一元素）。由於還保留著 previous 元素引用，要做的就是把 previous.next 的值改成 current.next。</p><h4 id="插入：在串列任意位置插入一個元素"><a href="#插入：在串列任意位置插入一個元素" class="headerlink" title="插入：在串列任意位置插入一個元素"></a>插入：在串列任意位置插入一個元素</h4><p>insert(position, element)，由於要處理到位置，就必須在一開始檢查臨界值，如果越界了就 return false，表示沒有完成添加。</p><ul><li>在串列起點添加一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist.jpg" class=""><p>current 是對串列第一個數的引用。我們要做的是把 node.next 的值設成 current。現在 head 和 node.next 都指向 current。接著就是將 head 改成 node，這樣串列就多一個元素了。</p><ul><li>在串列尾部添加元素</li></ul><p>首先，需要用迴圈存取串列，找到目標的 position。當跳出迴圈時，就是 current 到達我們想要插入新元素位置的後一個元素，而 previuos 是對想要插入新元素的位置之前一個元素的引用。在這情況下，我們要在 current, previous 之間添加，因此，首先要把新項目(node)和當前項目鏈結起來，然後再改變 previous 和 current 之間的鏈結，我們還要將 previous.next 指向 node。</p><img src="/posts/DataStructure-linkedList/linkedlist2.jpg" class=""><p>如果我們試圖向最後一位添加新項目，previous 將會是串列最後一個，而 current 將會是 null。在這情況，node.next 將指向 current，而 previous.next 指向 node。</p><ul><li>在串列中間添加元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist3.jpg" class=""><p>試著將 node 插入到 prev, curr 之間。首先，我們要把 node.next 指向 curr。然後把 prev.next 的值設為 node，這樣就完成囉。</p><h2 id="雙向鏈結串列-Double-Linked-List"><a href="#雙向鏈結串列-Double-Linked-List" class="headerlink" title="雙向鏈結串列 (Double Linked List)"></a>雙向鏈結串列 (Double Linked List)</h2><img src="/posts/DataStructure-linkedList/linkedlist8.png" class=""><p>相較原型，雙向鏈結的串列 node 多了一個 prev，而 list 也多了一個 tail。<br>我們可想而知，多了向前的鏈結，讓我們可以解開單向迭代的枷鎖，不只可以從頭到尾，也可以反過來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DoublyLinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>; <span class="comment">// 雙向串列才有</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">// 雙向串列才有</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在任意位置添加新元素"><a href="#在任意位置添加新元素" class="headerlink" title="在任意位置添加新元素"></a>在任意位置添加新元素</h3><p>和單向的鏈結串列的區別在於，雙向鏈結串列需要同時控制 next, prev 兩個指位器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">element, position</span>) &#123;</span><br><span class="line">  <span class="comment">// 檢查是否越界</span></span><br><span class="line">  <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current = head,</span><br><span class="line">        previous,</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 項目添加在第一個位置</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 空串列</span></span><br><span class="line">      <span class="keyword">if</span> (!head) &#123; <span class="comment">// new</span></span><br><span class="line">        head = node;</span><br><span class="line">        tail = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.<span class="property">next</span> = current;</span><br><span class="line">        current.<span class="property">prev</span> = node; <span class="comment">// new</span></span><br><span class="line">        head = node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length)&#123; <span class="comment">// 添加在最後一項 // new</span></span><br><span class="line">      current = tail;</span><br><span class="line">      current.<span class="property">next</span> = node;</span><br><span class="line">      node.<span class="property">prev</span> = current;</span><br><span class="line">      tail = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node.<span class="property">next</span> = current;</span><br><span class="line">      previous.<span class="property">next</span> = node;</span><br><span class="line"></span><br><span class="line">      current.<span class="property">prev</span> = node; <span class="comment">// new</span></span><br><span class="line">      node.<span class="property">prev</span> = previous; <span class="comment">// new</span></span><br><span class="line">    &#125;</span><br><span class="line">    length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="環狀鏈結串列"><a href="#環狀鏈結串列" class="headerlink" title="環狀鏈結串列"></a>環狀鏈結串列</h2><p>環狀鏈結串列可以單向也可以雙向。和鏈結串列不同的是，最後尾端指向的不是 null，而是第一個元素 (head)。</p><img src="/posts/DataStructure-linkedList/linkedlist9.jpg" class=""><h2 id="結"><a href="#結" class="headerlink" title="結"></a>結</h2><p>我們今天學到了鏈結串列這個結構，和陣列相比最重要的優點就是無需移動鏈結串列中的元素，就能輕輕鬆鬆添加或移除元素。<br>當你需要添加和移除很多元素時，最好的選擇非鏈結串列(Linked-List)莫屬！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這週要帶各位認識的資料結構是「 鏈結串列 Linked-List 」，一開始所學的陣列（串列）是一種非常簡易能讓我們存放資料序列的資料結構，而鏈結串列則是一種動態的，我們進行新增或刪減元素，就會依照需求進行擴充。陣列應該是大家最常用的資料結構，每種語言都支持它，但是卻有一個隱憂：在大多數的語言中，&lt;strong&gt;陣列的大小是固定的&lt;/strong&gt;，從起點或中間插入、移除元素是非常耗成本的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』佇列 Queue</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-queue/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-queue/</id>
    <published>2022-10-25T02:17:23.000Z</published>
    <updated>2023-04-15T06:37:09.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第三週我們歡迎「 Queue 佇列 」，上週我們學會了 stack ，這兩個東西非常相似，但是原則不同！<br>佇列在尾端新增元素，在頂部移除，在現實中就像是我們在排隊一樣，排在前面的人會優先被服務到，因此也有一個別稱叫做「 隊列 」。</p><img src="/posts/DataStructure-queue/queue.webp" class=""><span id="more"></span><h2 id="佇列什麼來頭？"><a href="#佇列什麼來頭？" class="headerlink" title="佇列什麼來頭？"></a>佇列什麼來頭？</h2><p>佇列是遵守著 FIFO (First In First Out, 先進先出) 原則的有序項目。</p><ul><li>一群相同性質元素的組合</li><li>具有 FIFO 特性</li><li>加入元素發生在尾端</li><li>刪除元素發生在頂端</li></ul><p>在 Computer Science 中，最常看到的例子就是列印佇列。假如我們要列印三份文件，會開啟檔案並按下列印的按鈕，每個文件都會被發送至列印佇列，第一個發送到的文件會首先被列印出來，直到所有文件都列印完成。</p><h2 id="建立佇列"><a href="#建立佇列" class="headerlink" title="建立佇列"></a>建立佇列</h2><h3 id="宣告類別"><a href="#宣告類別" class="headerlink" title="宣告類別"></a>宣告類別</h3><p>首先來宣告一個類別來建立自己的佇列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Queue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 寫入屬性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們需要一個用於存放元素的結構，這邊可以使用陣列，就像上一篇 Stack 那樣做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = []</span><br></pre></td></tr></table></figure><h3 id="宣告方法"><a href="#宣告方法" class="headerlink" title="宣告方法"></a>宣告方法</h3><p>接下來讓我們開始宣告方法吧！以下是佇列可用的幾種方法：</p><ul><li>enqueue(element(s)): 向佇列尾端增加一個(或多個)新元素。</li><li>dequeue(): 刪除佇列第一個元素(即排在最前面的)，並返回該元素。</li><li>front(): 返回佇列第一個元素－－最先加入的。（與 Stack 的 peek 方法極為相似）</li><li>isEmpty(): 如果佇列中不包含任何元素，返回 true，反之返回 false。</li><li>size(): 返回佇列裡的元素個數，與陣列的 length 相同。</li></ul><p>第一個就是我們的‘新增’，記住佇列只能從未端添加！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">enqueue</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">  items.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實作佇列移除元素。由於只能遵循先進先出原則，最先加入的也是最先移除的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">dequeue</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="title function_">shift</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有 enqueue, dequeue 兩種方法可以新增及刪除元素，這樣確保了 Queue 類別先進先出的規則。</p><p>接著就是屬於比較輔助的方法。<br>如果想知道佇列最前面的元素是什麼，可以用 front 方法，將返回佇列 index 為 0 的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">front</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isEmpty 如果佇列為空，返回 true，反之 false。常用於驗證。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後我們可以讓 Queue 類別實作類似 Array 類別的 length 屬性的方法。size 方法也和 Stack 裡的一樣：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到這邊，我們完成了！</p><h3 id="完整-Queue-類別"><a href="#完整-Queue-類別" class="headerlink" title="完整 Queue 類別"></a>完整 Queue 類別</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Queue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">enqueue</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    items.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dequue</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">front</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)[</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="與-Stack-不同之處"><a href="#與-Stack-不同之處" class="headerlink" title="與 Stack 不同之處"></a>與 Stack 不同之處</h2><p>唯一的區別是 dequeue 方法和 front 方法，這是由於先進先出和後進先出原則的不同所造成的。</p><h2 id="使用-Queue-類別"><a href="#使用-Queue-類別" class="headerlink" title="使用 Queue 類別"></a>使用 Queue 類別</h2><p>第一步：實例化 Queue。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">isEmpty</span>()); <span class="comment">// 輸出 true</span></span><br></pre></td></tr></table></figure><p>新增一些元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;Mike&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以玩一玩其他的方法～</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="title function_">dequeue</span>();</span><br><span class="line">queue.<span class="title function_">size</span>(); <span class="comment">// 1</span></span><br><span class="line">queue.<span class="title function_">isEmpty</span>();  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="特殊佇列"><a href="#特殊佇列" class="headerlink" title="特殊佇列"></a>特殊佇列</h2><h3 id="優先佇列"><a href="#優先佇列" class="headerlink" title="優先佇列"></a>優先佇列</h3><p>佇列大量的應用在我們的生活中和電腦科學中，我們在之前的實作原型佇列中，也有其他的延伸。<br>其中一個就是「優先佇列」。元素的添加、移除是基於優先級別的。機場的登機順序就是一個現實的例子，頭等艙和商務艙的優先級要高於經濟艙的乘客。有些國家，老人和孕婦也擁有高於其他乘客的級別。</p><p>另一個例子是醫院的急診室，醫生會優先處理重症患者，而護士通常會先行分類並決定次序。</p><img src="/posts/DataStructure-queue/queue1.jpg" class=""><p><em>取自<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9tL2FydGljbGVzLzEwMjY2OTgw">https://ithelp.ithome.com.tw/m/articles/10266980<i class="fa fa-external-link-alt"></i></span></em></p><p>實作一個優先佇列，有兩個選項：</p><ul><li>一是設定優先級，然後在正確的位置增加元素。</li><li>二是用入列操作新增元素，然候依照優先級移除它們。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PriorityQueue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">QueueElement</span>(<span class="params">element, priority</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">priority</span> = priority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">enqueue</span> = <span class="keyword">function</span>(<span class="params">element, priority</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> queueElement = <span class="title function_">newQueueElement</span>(element, priority);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">      items.<span class="title function_">push</span>(queueElement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> added = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;items.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(queueElement.<span class="property">priority</span> &lt; items[i].<span class="property">priority</span>)&#123;</span><br><span class="line">          items.<span class="title function_">splice</span>(i, <span class="number">0</span>, queueElement);</span><br><span class="line">          added = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!added)&#123;</span><br><span class="line">        items.<span class="title function_">push</span>(queueElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他方法和預設的 Queue 實作相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>預設的類別和優先級佇列類別實作上的區別是，要向 PriorityQueue 新增元素，需要建立一個特殊元素。這個元素包含了要添加到佇列的元素（它可以是任意類型）及其在佇列中的優先級。</p><p>如果佇列為空，可以直接加入。否則，就需要先比較該元素與其他元素的優先級。當找到一個比要添加元素還要大的 priority 項目時，就把新元素插入到它之前（根據這個邏輯，相同優先級通樣要遵循先進先出原則）。</p><p>補充一點，這裡實作的稱為最小優先佇列，因為優先級較小被放置在最前面（ 1 表示更高優先 ）。最大優先佇列則與之相反。</p><h3 id="環狀佇列"><a href="#環狀佇列" class="headerlink" title="環狀佇列"></a>環狀佇列</h3><p>另一個延伸就是「環狀佇列」。遊戲燙手山芋（ Hot Potato ）就是一個很好的例子。<br>遊戲中，玩家圍成一個圈，把物品盡快地遞給旁邊的人，某一時刻傳遞停止，而這時候物品在誰手上，誰就退出圓圈結束遊戲。重複這個過程，直到一位勝者出爐。</p><img src="/posts/DataStructure-queue/queue2.webp" class=""><p><em>取自<span class="exturl" data-url="aHR0cHM6Ly93d3cuMTIzcmYuY29tL3Bob3RvXzEwOTE4MTAwX3Bhc3Npbmctb24tdGhlLWhvdC1wb3RhdG8tYS1jb25jZXB0Lmh0bWw=">https://www.123rf.com/photo_10918100_passing-on-the-hot-potato-a-concept.html<i class="fa fa-external-link-alt"></i></span></em></p><p>實作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">nameList, num</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nameList.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> eliminated = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    eliminated = queue.<span class="title function_">dequeue</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(eliminated + <span class="string">&#x27;在遊戲中被淘汰。&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queue.<span class="title function_">dequeue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Colin&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Eileen&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> winner = <span class="title function_">hotPotato</span>(names, <span class="number">7</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;勝利者&#x27;</span> + winner);</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>我們這次學習了佇列的資料結構，自己實作佇列的演算法，學習如何透過 enqueue, dequeue 方法增加和刪除元素。還有兩種著名的特殊佇列實作：優先佇列、環狀佇列。</p><p>接下來我們將學習鏈結串列，比陣列更加複雜的資料結構呦！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第三週我們歡迎「 Queue 佇列 」，上週我們學會了 stack ，這兩個東西非常相似，但是原則不同！&lt;br&gt;佇列在尾端新增元素，在頂部移除，在現實中就像是我們在排隊一樣，排在前面的人會優先被服務到，因此也有一個別稱叫做「 隊列 」。&lt;/p&gt;
&lt;img src=&quot;/posts/DataStructure-queue/queue.webp&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』堆疊 Stack</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-stack/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-stack/</id>
    <published>2022-10-14T08:39:51.000Z</published>
    <updated>2023-04-09T07:31:57.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>準備好歡迎我們第二週的主題“堆疊”了嗎！<br>在電腦科學的江湖上流傳著一句話：</p><blockquote><p>程式設計 ＝ 資料結構 ＋ 演算法</p></blockquote><p>在各大專院校裡，這幾門課都列為必修課之一，但是大多缺乏語言的基礎，反而在這裡頭迷失了，學完就好像睡了一覺，模模糊糊迷迷茫茫…，我就是這樣😂</p><p>本篇將使用 JavaScript 來學習堆疊(Stack)的資料結構。</p><span id="more"></span><h2 id="堆疊是什麼？"><a href="#堆疊是什麼？" class="headerlink" title="堆疊是什麼？"></a>堆疊是什麼？</h2><p>堆疊是一種按照<em>後進先出</em> (LIFO, Last In First Out)的有序結構，舉個例子：日常生活中的疊盤子。先疊的盤子會在最下面，後面開始會疊在上方，一層一層往上，當要拿盤子時一定是從最上面拿。</p><p><img src="https://i0.wp.com/studyalgorithms.com/wp-content/uploads/2020/12/stack-of-plates_0.png?ssl=1" alt="疊盤子"></p><h2 id="建立堆疊"><a href="#建立堆疊" class="headerlink" title="建立堆疊"></a>建立堆疊</h2><p>開始進入實作的階段，GOGO🤟🏻</p><h3 id="類別"><a href="#類別" class="headerlink" title="類別"></a>類別</h3><p>首先，建立一個類別為 Stack:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Stack</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//宣告內部屬性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="屬性"><a href="#屬性" class="headerlink" title="屬性"></a>屬性</h3><p>我們下面會用 Array 的方式進行，所以宣告起來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [];</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>新增 push(element)、刪除 pop()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">  items.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刪除元素：會返回被移除的元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="title function_">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最上方元素為何 peek(), top()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回最上方元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items[items.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆疊還有元素嗎 isEmpty()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆疊內部是否還有元素存在 true, false</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>元素共有幾個 size()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆疊內部有多少元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>清空堆疊 clear()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆疊清空</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Stack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    items.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items[items.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="動手做做看"><a href="#動手做做看" class="headerlink" title="動手做做看"></a>動手做做看</h2><p>快速測試可以打開 chrome 的 console 操作看看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="string">&#x27;plateA&#x27;</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="string">&#x27;plateB&#x27;</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="string">&#x27;plateC&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack); <span class="comment">// [&#x27;plateA&#x27;, &#x27;plateB&#x27;, &#x27;plateC&#x27;]</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">pop</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack); <span class="comment">// [&#x27;plateA&#x27;, &#x27;plateB&#x27;]</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">size</span>() <span class="comment">// 2</span></span><br><span class="line">stack.<span class="title function_">peek</span>() <span class="comment">// &#x27;plantB&#x27;</span></span><br><span class="line">stack.<span class="title function_">clear</span>() <span class="comment">// []</span></span><br><span class="line">stack.<span class="title function_">isEmpty</span>() <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最後到 leetcode 驗收一下自己學習的成果吧！<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXF1ZXVlLXVzaW5nLXN0YWNrcy8=">232. Implement Queue using Stacks<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">20. Valid Parentheses<i class="fa fa-external-link-alt"></i></span></p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zdHVkeWFsZ29yaXRobXMuY29tL3RoZW9yeS9zdGFjay1kYXRhLXN0cnVjdHVyZS8=">What is a Stack?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxNTExOA==">前端工程師用 javaScript 學演算法<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNSVBMCU4NiVFNiVBMCU4OA==">堆疊- 維基百科，自由的百科全書 - Wikipedia<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;準備好歡迎我們第二週的主題“堆疊”了嗎！&lt;br&gt;在電腦科學的江湖上流傳著一句話：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程式設計 ＝ 資料結構 ＋ 演算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在各大專院校裡，這幾門課都列為必修課之一，但是大多缺乏語言的基礎，反而在這裡頭迷失了，學完就好像睡了一覺，模模糊糊迷迷茫茫…，我就是這樣😂&lt;/p&gt;
&lt;p&gt;本篇將使用 JavaScript 來學習堆疊(Stack)的資料結構。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Mac 中文輸入法無法顯示選字框？</title>
    <link href="https://colinchiu87.github.io/posts/Mac-bug-inputMethod/"/>
    <id>https://colinchiu87.github.io/posts/Mac-bug-inputMethod/</id>
    <published>2022-10-04T09:05:15.000Z</published>
    <updated>2022-10-17T09:25:10.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有一天在輸入文字的時候，感覺上好像有點怪怪的…，但是又說不出是什麼，打著打著要選字就發現怎麼只能用鍵盤的上下左右盲選字！<br>不知道是不是我自己很少重新開機。<br>趕忙爬文，還以為電腦要壽終正寢了(才用一年多…QAQ</p><span id="more"></span><h2 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h2><p>本人的電腦是 2021 M1 Mac Pro<br>在網路上查到解決的辦法是在終端機上輸入：</p><blockquote><p>killall TCIM_Extension</p></blockquote><p>這個指令是將注音這隻殺掉，然後系統會將殺掉的程式重新開啟，之後就不需要針對單一問題重新開機了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有一天在輸入文字的時候，感覺上好像有點怪怪的…，但是又說不出是什麼，打著打著要選字就發現怎麼只能用鍵盤的上下左右盲選字！&lt;br&gt;不知道是不是我自己很少重新開機。&lt;br&gt;趕忙爬文，還以為電腦要壽終正寢了(才用一年多…QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mac" scheme="https://colinchiu87.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Big O 分析演算法好壞</title>
    <link href="https://colinchiu87.github.io/posts/Algorithm-bigO/"/>
    <id>https://colinchiu87.github.io/posts/Algorithm-bigO/</id>
    <published>2022-10-04T03:19:07.000Z</published>
    <updated>2022-11-17T13:04:45.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同樣一個問題可以用不同的演算法解答，那我們要如何去區分當中的好與壞呢？<br>對於這樣的疑問有人提出了一種解答 - Big O.</p><span id="more"></span><h2 id="Big-O-表示法"><a href="#Big-O-表示法" class="headerlink" title="Big O 表示法"></a>Big O 表示法</h2><p>分析演算法的優劣，通常是使用資源來評量，ex: CPU 佔用量、Memory 佔用量、磁碟、網路等等。<br>當說到 big o 時，一般考慮的就是 CPU (時間)佔用。在分析時很常會看到以下的函數：</p><table><thead><tr><th align="center">符號</th><th align="center">名稱</th></tr></thead><tbody><tr><td align="center">O(1)</td><td align="center">常數型</td></tr><tr><td align="center">O(log(n))</td><td align="center">對數型</td></tr><tr><td align="center">O(log(n)c)</td><td align="center">對數多項式型</td></tr><tr><td align="center">O(n)</td><td align="center">線性型</td></tr><tr><td align="center">O(n^2)</td><td align="center">二次型</td></tr><tr><td align="center">O(n^c)</td><td align="center">多項式型</td></tr><tr><td align="center">O(c^n)</td><td align="center">指數型</td></tr></tbody></table><blockquote><p>Big O 是用來描述演算法在輸入 n 個數時，總時間與 n 的關係。</p></blockquote><img src="/posts/Algorithm-bigO/Algorithm-bigO1.png" class=""><blockquote><p>常見排序： 1(常數) &lt; log n &lt; n &lt; n log n &lt; n^2 &lt; 2^n &lt; n!</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;同樣一個問題可以用不同的演算法解答，那我們要如何去區分當中的好與壞呢？&lt;br&gt;對於這樣的疑問有人提出了一種解答 - Big O.&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="Algorithm" scheme="https://colinchiu87.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』陣列 Array By JavaScript</title>
    <link href="https://colinchiu87.github.io/posts/Js-array/"/>
    <id>https://colinchiu87.github.io/posts/Js-array/</id>
    <published>2022-10-02T09:27:42.000Z</published>
    <updated>2022-11-17T13:04:05.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這週與前端小夥伴們發起了 JavaScript 資料結構 (data structure) 讀書會，二話不說用微薄的薪資擠出了些孔方兄購入兩本工具書規劃一下學習計畫，這週從最基礎的陣列 (Array) 走起！<br>是哪兩本書我會放在最後給大家參考，也希望有想學習這方面的小夥伴每週跟著我的腳步一起成長八 ❤️</p><span id="more"></span><h2 id="陣列-Array"><a href="#陣列-Array" class="headerlink" title="陣列 Array"></a>陣列 Array</h2><p>在眾多的語言中，陣列是大家原生都有支援的類型，是最常見的負責<strong>存放一系列相同類別資料</strong>的方法。<br><del>但在 JS 裡是可以在裡頭儲存不同類型的值</del>。這部分我們就不探討了。</p><h3 id="為什麼要用陣列"><a href="#為什麼要用陣列" class="headerlink" title="為什麼要用陣列"></a>為什麼要用陣列</h3><p>假設有一個需求，記錄下這星期每一天吃的熱量總數：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calorieMon = <span class="number">3500</span>;</span><br><span class="line"><span class="keyword">var</span> calorieTue = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieWed = <span class="number">2700</span>;</span><br><span class="line"><span class="keyword">var</span> calorieThu = <span class="number">3200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieFri = <span class="number">2200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieSat = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieSun = <span class="number">4800</span>;</span><br></pre></td></tr></table></figure><p>方法沒有不行但肯定不是最佳。以這種方式，如果只有一週自然只有 7 個變數，那要記錄半年呢？<br>這個時候就要慶幸有陣列來幫助我們更有效率解決：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">0</span>] = <span class="number">3500</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">1</span>] = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">2</span>] = <span class="number">2700</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">3</span>] = <span class="number">3200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">4</span>] = <span class="number">2200</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">5</span>] = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">var</span> calorieArr[<span class="number">6</span>] = <span class="number">4800</span>;</span><br><span class="line"></span><br><span class="line">calorieArr = [<span class="number">3500</span>, <span class="number">5000</span>, <span class="number">2700</span>, <span class="number">3200</span>, <span class="number">2200</span>, <span class="number">3000</span>, <span class="number">4800</span>];</span><br></pre></td></tr></table></figure><h3 id="宣告和初始化"><a href="#宣告和初始化" class="headerlink" title="宣告和初始化"></a>宣告和初始化</h3><p>宣告的方式有幾種：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">7</span>); <span class="comment">// 指定長度</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Leo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">// 最常使用的宣告方式</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Leo&#x27;</span>];</span><br></pre></td></tr></table></figure><h3 id="基本屬性"><a href="#基本屬性" class="headerlink" title="基本屬性"></a>基本屬性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陣列元素的數量</span></span><br><span class="line">arr.<span class="property">length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存取指定位置的元素可以使用中括號傳遞索引值    p.s.索引是從 0 開始</span></span><br><span class="line">arr[index]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 藉由迴圈遍歷陣列，輸出全部元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素的添加和刪除"><a href="#元素的添加和刪除" class="headerlink" title="元素的添加和刪除"></a>元素的添加和刪除</h3><p>以下我們就使用這個範例來做一些教學八</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>添加元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 先來個陽春直覺版</span></span><br><span class="line">arr[arr.<span class="property">length</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// arr = [0, 1, 2, 3, 4, 5, 6];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push 屬性(加入元素位於“尾端”)</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">7</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// arr = [0, 1, 2, 3, 4, 5, 6, 7];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unshift 屬性(加入元素位於“首端”)</span></span><br><span class="line">arr.<span class="title function_">unshift</span>(-<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// arr = [-1, 0, 1, 2, 3, 4, 5, 6, 7];</span></span><br></pre></td></tr></table></figure><p>刪除元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// pop 屬性(刪除元素位於“尾端”)</span></span><br><span class="line">arr.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// arr = [0, 1, 2, 3, 4];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift 屬性(刪除元素位於“首端”)</span></span><br><span class="line">arr.<span class="title function_">shift</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// arr = [1, 2, 3, 4];</span></span><br></pre></td></tr></table></figure><p>在後面的章節裡，會藉由 push, pop 方法，模擬<strong>堆疊</strong>資料結構；而 shift 和 unshift 則模擬<strong>佇列</strong>資料結構。</p><p>到這邊為止，介紹了從頭尾去新增及刪除元素，那我們要怎麼從中間去操作呢？<br>讓我們接下去看到 splice 屬性，這也是我覺得很便利的方法！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// splice 屬性</span></span><br><span class="line"><span class="comment">// splice(要操作的索引值, 刪除的個數, 增加的元素(選填，可多個))</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// arr = [0, 1, 2, 5]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">// 在第三索引的地方插入兩個元素 8, 8，因為沒有要刪除所以個數寫上 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// arr = [0, 8, 8, 1, 2, 5]</span></span><br></pre></td></tr></table></figure><h3 id="二維及多維陣列"><a href="#二維及多維陣列" class="headerlink" title="二維及多維陣列"></a>二維及多維陣列</h3><p>二維用表格來解釋會相當容易理解，下方是一個 3x3 的表格也代表著一種二維陣列</p><table><thead><tr><th align="center">A1</th><th align="center">A2</th><th align="center">A3</th></tr></thead><tbody><tr><td align="center">A4</td><td align="center">A5</td><td align="center">A6</td></tr><tr><td align="center">A7</td><td align="center">A8</td><td align="center">A9</td></tr></tbody></table><p>A1的索引值：arr[0][0]<br>A2: arr[0][1]<br>A3: arr[0][2]…依此類推</p><p>幾維陣列的遍歷就要用幾層迴圈作。</p><h3 id="陣列方法"><a href="#陣列方法" class="headerlink" title="陣列方法"></a>陣列方法</h3><table><thead><tr><th align="center">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">concat</td><td align="left">連接多個陣列，return 結果</td></tr><tr><td align="center">every</td><td align="left">對陣列每一個元素運行函數，每一個元素都是 true，才會 return true</td></tr><tr><td align="center">filter</td><td align="left">對陣列每一個元素運行函數，集合  true 的元素 return 陣列</td></tr><tr><td align="center">forEach</td><td align="left">對陣列每一個元素運行函數</td></tr><tr><td align="center">join</td><td align="left">將所有元素串成一個字串</td></tr><tr><td align="center">indexOf</td><td align="left">return 第一個相等參數的索引值，無符合 return -1</td></tr><tr><td align="center">lastIndexOf</td><td align="left">return 最後一個相等參數的索引值，無符合 return -1</td></tr><tr><td align="center">map</td><td align="left">對陣列每一個元素運行函數，return 每次函數所呼叫的結果所組成之陣列</td></tr><tr><td align="center">reverse</td><td align="left">反轉陣列裡的元素</td></tr><tr><td align="center">slice</td><td align="left">傳入索引值，return 索引範圍內的元素新陣列</td></tr><tr><td align="center">some</td><td align="left">對陣列每一個元素運行函數，有任意 true ，return true</td></tr><tr><td align="center">sort</td><td align="left">按照 ASCII 值做排序，支援傳入指定排序函數做參數</td></tr><tr><td align="center">toString</td><td align="left">return 將陣列轉字串</td></tr><tr><td align="center">valueOf</td><td align="left">和 toString 相似，return 將陣列轉字串</td></tr></tbody></table><h2 id="工具書"><a href="#工具書" class="headerlink" title="工具書"></a>工具書</h2><ul><li>JavaScript 資料結構及演算法實作 - Loiane Groner</li><li>演算法圖鑑 - 石田保輝、宮崎修一</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這週與前端小夥伴們發起了 JavaScript 資料結構 (data structure) 讀書會，二話不說用微薄的薪資擠出了些孔方兄購入兩本工具書規劃一下學習計畫，這週從最基礎的陣列 (Array) 走起！&lt;br&gt;是哪兩本書我會放在最後給大家參考，也希望有想學習這方面的小夥伴每週跟著我的腳步一起成長八 ❤️&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="Algorithm" scheme="https://colinchiu87.github.io/tags/Algorithm/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
    <category term="Frontend" scheme="https://colinchiu87.github.io/tags/Frontend/"/>
    
    <category term="array" scheme="https://colinchiu87.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>一失足掉進的坑 Hexo Config</title>
    <link href="https://colinchiu87.github.io/posts/Hexo-config-permalink/"/>
    <id>https://colinchiu87.github.io/posts/Hexo-config-permalink/</id>
    <published>2022-09-17T09:23:24.000Z</published>
    <updated>2022-10-17T09:24:51.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有在使用 Hexo Blog 的朋友一定知道他有很多設定可以玩！除了一般的標題、簡介、相關連結外，還有分頁、閱讀進度、總閱覽人數…等等一大堆。<br>今日心血來潮想要把部落格的 config 設定弄的更完整一些，沒有想到居然在之中受困數個小時…，真的覺得自己好笑又好氣😓</p><span id="more"></span><h2 id="permalink-永久連結"><a href="#permalink-永久連結" class="headerlink" title="permalink 永久連結"></a>permalink 永久連結</h2><p>這是設定關於網站文章的連結（ URL ），就是點進你的文章後上面所顯使的連結樣式</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>       <span class="comment"># 預設 Ex: 2013/07/14/hello-world/</span></span><br></pre></td></tr></table></figure><p>Hexo 文件有告訴大家說可以使用變數(文章尾端附圖)以及 Front-matter 做變化。看到這裡根本不知道不行自訂對吧！對吧！對吧…?<br>所以我就自作主張改成了以下這樣：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:title/</span>       <span class="comment"># Ex: posts/hello-world/</span></span><br></pre></td></tr></table></figure><p>原本想說網址太長多少會影響 SEO 的表現，所以我不想要時間在前面佔空間，還有這樣 public 資料夾的文章會被收在 posts 的資料夾裡不會散落一地，看起來才會讓我蘇湖🤤。<br>接下來 Deploy 出去就發現文章都連不進去啦啦啦😱，在改這個設定的時候，我已經有幾篇文章了，以為是動到了已發布文章的路徑才造成如此，便開始我的 Debug 之路，翻啊找啊爬啊根本沒有搜尋到什麼相關的東西，回頭重新讀了一下文件，才領悟到無法自訂呀～只能透過 permalink_defaults 改寫你想要的東西。於是我就將我的 category 預設為 posts 然後改寫。</p><img src="/posts/Hexo-config-permalink/permalinks1.png" class=""><img src="/posts/Hexo-config-permalink/permalinks2.png" class=""><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>不要自作聰明… 😂</p><img src="/posts/Hexo-config-permalink/Permalinks.png" class="" title="[Permalink可用變數]">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有在使用 Hexo Blog 的朋友一定知道他有很多設定可以玩！除了一般的標題、簡介、相關連結外，還有分頁、閱讀進度、總閱覽人數…等等一大堆。&lt;br&gt;今日心血來潮想要把部落格的 config 設定弄的更完整一些，沒有想到居然在之中受困數個小時…，真的覺得自己好笑又好氣😓&lt;/p&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="https://colinchiu87.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>讓爬蟲程式照著規則來 robots.txt</title>
    <link href="https://colinchiu87.github.io/posts/Seo-robotsTxt/"/>
    <id>https://colinchiu87.github.io/posts/Seo-robotsTxt/</id>
    <published>2022-07-21T07:14:53.000Z</published>
    <updated>2022-11-17T13:01:40.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果有了解過 SEO ，那你可能有聽說過『 robots.txt 』這個名字。<br>主要用來避免網站要求太多，導致超載(<del>要求太多會人家討厭的</del><br>而簡單來說，他就是來讓爬蟲程式聽話的一個檔案，像是該爬這裡、不該走這裡，<br>但是但是但是…有機率會不聽話失效🤫。</p><p><img src="https://webris.org/wp-content/uploads/2017/12/robots_txt_file_explained.gif" alt="robots.txt示意圖"></p><span id="more"></span><h2 id="建議使用的理由"><a href="#建議使用的理由" class="headerlink" title="建議使用的理由"></a>建議使用的理由</h2><p>robots.txt 檔案主用途在於管理爬蟲對自己網站的流量，<strong>直接了當的與爬蟲溝通</strong>；“正常情況下”可以讓搜尋引擎的結果不顯示特定檔案。<br>以下幾種情況是建議使用的：</p><ul><li>網站還有未完成或需要測試時。</li><li>有網頁內容重複性太高時。</li><li>網站內有一些相對不重要的資訊，浪費資源。</li><li>擁有機密檔案。</li></ul><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><p>他網有連結到設置封鎖的網頁，索引還是會被建立。<br>只是要自己的網頁不要出現在搜尋引擎上就請不要用這個方法，就算你使用 robots.txt 來限制，只要有別的網頁有說明文字指向你，那麼即使爬蟲未造訪這裡，也會被建立成索引。以下提供其他的方法給大家：密碼保護、noindex。</p></li><li><p>不是所有的搜尋引擎都會支援。<br>不同的檢索器會自行決定要不要遵守，所以並不是強制性的。（Googlebot是好寶寶他會）</p></li><li><p>不同檢索器語法的使用不一定相同。<br>我們平時熟知的大宗搜尋引擎都聽得懂，但就是有人會理解成不同的意思，這時候我們就必須應材施教了。</p></li></ul><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><h3 id="基本規則"><a href="#基本規則" class="headerlink" title="基本規則"></a>基本規則</h3><p>一開始先介紹一些基本的規範、格式～</p><ul><li>一個網站只能存在一個 robots.txt 檔案。</li><li>檔名只能是 robots.txt ，不能當手遊的名字一樣亂取…PikaChiu（喂🤭</li><li>檔案要放在根目錄。</li></ul><h3 id="建立檔案並新增規則"><a href="#建立檔案並新增規則" class="headerlink" title="建立檔案並新增規則"></a>建立檔案並新增規則</h3><p>第一步先用編輯器建立一個名叫 robots.txt 的文字檔，這邊要<strong>注意</strong>的是不要用文書處理軟體，人家說有可能會有問題。<br>再來就是重頭戲了，告訴你用三個單字搞定</p><ul><li>User_Agent: 爬蟲的名字，例如：Googlebot。</li><li>Allow: 允許人家“可以”爬的。</li><li>Disallow: “不同意”人家進來爬的。</li></ul><p>好了教完了😂😂😂</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>用一些範例來講解，大家應該就可以很快上手。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果有了解過 SEO ，那你可能有聽說過『 robots.txt 』這個名字。&lt;br&gt;主要用來避免網站要求太多，導致超載(&lt;del&gt;要求太多會人家討厭的&lt;/del&gt;&lt;br&gt;而簡單來說，他就是來讓爬蟲程式聽話的一個檔案，像是該爬這裡、不該走這裡，&lt;br&gt;但是但是但是…有機率會不聽話失效🤫。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://webris.org/wp-content/uploads/2017/12/robots_txt_file_explained.gif&quot; alt=&quot;robots.txt示意圖&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="SEO" scheme="https://colinchiu87.github.io/tags/SEO/"/>
    
    <category term="crawler" scheme="https://colinchiu87.github.io/tags/crawler/"/>
    
  </entry>
  
</feed>
