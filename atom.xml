<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凹逗工程師</title>
  
  <subtitle>成為一個更好的人</subtitle>
  <link href="https://colinchiu87.github.io/atom.xml" rel="self"/>
  
  <link href="https://colinchiu87.github.io/"/>
  <updated>2025-10-29T06:47:34.213Z</updated>
  <id>https://colinchiu87.github.io/</id>
  
  <author>
    <name>Kuan Ru</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tailwind CSS 專業技巧與竅門：讓你的 UI 升級 🚀</title>
    <link href="https://colinchiu87.github.io/posts/Css-tailwindSkill/"/>
    <id>https://colinchiu87.github.io/posts/Css-tailwindSkill/</id>
    <published>2025-10-29T06:20:15.000Z</published>
    <updated>2025-10-29T06:47:34.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>許多開發者在使用 Tailwind CSS 時，可能只停留在基礎的實用類別應用。但其實 Tailwind 隱藏了許多鮮為人知但極為強大的技巧，可以幫助你用更少的程式碼實現更高階的 UI 效果。</p><p>這篇文章將分享幾個連許多資深開發者都不知道的 Tailwind CSS 專業技巧！</p><img src="/posts/Css-tailwindSkill/tailwindcss.png" class=""><span id="more"></span><h2 id="1-特殊的-UI-元素客製化"><a href="#1-特殊的-UI-元素客製化" class="headerlink" title="1. 特殊的 UI 元素客製化"></a>1. 特殊的 UI 元素客製化</h2><h3 id="🎨-自訂瀏覽器重點色-Accent-Color"><a href="#🎨-自訂瀏覽器重點色-Accent-Color" class="headerlink" title="🎨 自訂瀏覽器重點色 (Accent Color)"></a>🎨 自訂瀏覽器重點色 (Accent Color)</h3><p>你是否想過更改瀏覽器中預設的核取方塊（checkboxes）或單選按鈕（radio groups）的藍色？使用 Tailwind 輕而易舉。</p><ul><li>技巧： 使用 <code>accent-&#123;color&#125;</code> 實用程式。</li><li>應用： 只需為表單元素添加 <code>class=&quot;accent-pink-500&quot;</code>，即可讓你的表單元素獲得完全客製化的重點色，與你的品牌設計完美融合。</li></ul><h3 id="📁-輕鬆美化檔案輸入框（File-Input）"><a href="#📁-輕鬆美化檔案輸入框（File-Input）" class="headerlink" title="📁 輕鬆美化檔案輸入框（File Input）"></a>📁 輕鬆美化檔案輸入框（File Input）</h3><p>傳統上，美化 <code>&lt;input type=&quot;file&quot;&gt;</code> 是一件令人頭痛的事。Tailwind 提供了一個優雅的解決方案。</p><ul><li>技巧： 使用 file: 前綴。</li><li>應用： 你可以直接為檔案輸入框的不同部分定義樣式，例如 <code>file:border-r</code> 或 <code>file:text-blue-700</code>，省去了使用額外 JavaScript 或完全隱藏預設輸入框的麻煩。</li></ul><h2 id="2-提升響應式和互動性體驗"><a href="#2-提升響應式和互動性體驗" class="headerlink" title="2. 提升響應式和互動性體驗"></a>2. 提升響應式和互動性體驗</h2><h3 id="📏-實現流動式文字排版（Fluid-Typography）"><a href="#📏-實現流動式文字排版（Fluid-Typography）" class="headerlink" title="📏 實現流動式文字排版（Fluid Typography）"></a>📏 實現流動式文字排版（Fluid Typography）</h3><p>擺脫在特定斷點（breakpoints）上突然改變字體大小的生硬感，讓文字大小隨螢幕寬度平滑變化。</p><ul><li>問題： 傳統上依賴 sm:、lg: 媒體查詢改變字體大小。</li><li>技巧： 利用 任意值（Arbitrary Values） 結合 CSS 函數，如 <code>min()</code> 或 <code>clamp()</code>。</li><li>範例： 寫作 <code>text-[min(10vw, 70px)]</code>。這樣文字大小會根據視埠寬度（<code>vw</code>）進行計算，在指定範圍內實現完全流動和響應式的字體大小，帶來更順暢的視覺體驗。</li></ul><h3 id="🖱️-自訂文字選取區（Selection）高亮顏色"><a href="#🖱️-自訂文字選取區（Selection）高亮顏色" class="headerlink" title="🖱️ 自訂文字選取區（Selection）高亮顏色"></a>🖱️ 自訂文字選取區（Selection）高亮顏色</h3><p>當使用者選取螢幕上的文字時，預設會出現藍色高亮。你可以在 Tailwind 中輕鬆覆寫它。</p><ul><li>技巧： 使用 <code>selection:</code> 偽類。</li><li>應用： 添加 <code>selection:bg-green-500</code> <code>selection:text-white</code>，即可將選取時的背景色改為綠色、文字改為白色，客製化網站的每一個視覺細節。</li></ul><h2 id="3-程式碼優化與工作流程提升"><a href="#3-程式碼優化與工作流程提升" class="headerlink" title="3. 程式碼優化與工作流程提升"></a>3. 程式碼優化與工作流程提升</h2><h3 id="⚛️-用-Tailwind-寫更少的-JavaScript"><a href="#⚛️-用-Tailwind-寫更少的-JavaScript" class="headerlink" title="⚛️ 用 Tailwind 寫更少的 JavaScript"></a>⚛️ 用 Tailwind 寫更少的 JavaScript</h3><p>你是否經常使用 JavaScript 處理像手風琴（Accordion）這樣的簡單 UI 狀態？其實 Tailwind 搭配原生 HTML 標籤就能實現。</p><ul><li>技巧： 結合原生的 HTML <code>&lt;details&gt;</code> 和 <code>&lt;summary&gt;</code> 標籤，搭配 <code>open:</code> 前綴選擇器。</li><li>應用： 例如，使用 <code>open:bg-gray-100</code>，可以讓你在 <code>&lt;details&gt;</code> 標籤處於「打開」狀態時自動應用樣式，無需編寫任何 JavaScript 就能管理 UI 狀態。</li></ul><h3 id="⚙️-專業開發者的高效秘訣"><a href="#⚙️-專業開發者的高效秘訣" class="headerlink" title="⚙️ 專業開發者的高效秘訣"></a>⚙️ 專業開發者的高效秘訣</h3><p>如何才能像專業人士一樣，快速掌握並使用數千個 Tailwind 類別？</p><ol><li><p>放棄死記硬背： 你不需要記憶所有類別。透過持續的實踐，你會自然而然地對常見的類別產生肌肉記憶。</p></li><li><p>善用搜尋捷徑： 在 Tailwind CSS 的官方文件中，隨時按下 Command + K (Mac) 或 Ctrl + K (Win)，即可開啟快速搜尋欄，隨時查找任何 CSS 屬性對應的 Tailwind 類別。</p></li><li><p>安裝編輯器擴充功能： 務必安裝 Tailwind CSS 官方擴充功能（適用於 VS Code 或 WebStorm），它提供智慧提示、自動完成、顏色預覽和懸停詳細資訊，能極大地加快你的編寫速度。</p></li></ol><h3 id="📚-繼續精進：從零到專業的實戰課程"><a href="#📚-繼續精進：從零到專業的實戰課程" class="headerlink" title="📚 繼續精進：從零到專業的實戰課程"></a>📚 繼續精進：從零到專業的實戰課程</h3><p>掌握了這些 Tailwind CSS 的核心概念和進階技巧後，下一步就是將它們應用到實際專案中。我也還在實作練習中，一起在這旅途中加油！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;許多開發者在使用 Tailwind CSS 時，可能只停留在基礎的實用類別應用。但其實 Tailwind 隱藏了許多鮮為人知但極為強大的技巧，可以幫助你用更少的程式碼實現更高階的 UI 效果。&lt;/p&gt;
&lt;p&gt;這篇文章將分享幾個連許多資深開發者都不知道的 Tailwind CSS 專業技巧！&lt;/p&gt;
&lt;img src=&quot;/posts/Css-tailwindSkill/tailwindcss.png&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="CSS" scheme="https://colinchiu87.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端渲染模式大比拼：SSR vs SSG vs SPA</title>
    <link href="https://colinchiu87.github.io/posts/Ssr-know/"/>
    <id>https://colinchiu87.github.io/posts/Ssr-know/</id>
    <published>2025-10-19T13:22:34.000Z</published>
    <updated>2025-10-20T06:50:32.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在學習 Nuxt3，它是一個基於 Vue.js 的框架，提供了強大的功能來建構現代化的 Web 應用。其中最吸引我的就是它對不同渲染模式的支援，特別是伺服器端渲染（SSR）。在深入 Nuxt3 之前，我想先好好了解一下幾種常見的網頁渲染模式：SPA、SSR 和 SSG。這篇文章將會是我學習這幾個概念的筆記。</p><img src="/posts/Ssr-know/ssr1.webp" class=""><span id="more"></span><h2 id="網頁渲染模式簡介"><a href="#網頁渲染模式簡介" class="headerlink" title="網頁渲染模式簡介"></a>網頁渲染模式簡介</h2><p>在現代網頁開發中，我們主要有三種渲染模式：</p><ol><li><strong>SPA</strong> (Single-Page Application - 客戶端渲染 CSR)：單頁應用程式，內容在瀏覽器端渲染。</li><li><strong>SSR</strong> (Server-Side Rendering - 伺服器端渲染)：內容在伺服器端渲染成 HTML 後再傳送到瀏覽器。</li><li><strong>SSG</strong> (Static Site Generation - 靜態網站生成)：在建置時期就預先產生所有頁面的 HTML 檔案。</li></ol><p>這三種模式各有優缺點，適用於不同的應用場景。接下來讓我們一一探討。</p><h2 id="SPA-Single-Page-Application"><a href="#SPA-Single-Page-Application" class="headerlink" title="SPA (Single-Page Application)"></a>SPA (Single-Page Application)</h2><p>SPA 是目前前端開發的主流模式之一，像我們熟悉的 Vue、React、Angular 等框架，預設都是以 SPA 模式運作。</p><h3 id="SPA-運作方式"><a href="#SPA-運作方式" class="headerlink" title="SPA 運作方式"></a>SPA 運作方式</h3><ol><li><strong>初始請求</strong>：瀏覽器第一次向伺服器請求頁面時，伺服器會回傳一個幾乎空白的 <code>index.html</code> 檔案，以及打包好的 JavaScript 和 CSS 檔案。</li><li><strong>客戶端渲染</strong>：瀏覽器下載完 JavaScript 後，開始在客戶端執行，透過 JavaScript 動態產生頁面內容（DOM），並掛載到 <code>index.html</code> 的根節點上。</li><li><strong>後續導航</strong>：當使用者點擊連結切換頁面時，並不會向伺服器重新請求整個頁面。而是透過前端路由（如 <code>vue-router</code>）來攔截請求，動態更新頁面內容，提供流暢如原生應用程式般的使用者體驗。</li></ol><h3 id="SPA-優點"><a href="#SPA-優點" class="headerlink" title="SPA 優點"></a>SPA 優點</h3><ul><li><strong>使用者體驗佳</strong>：頁面切換快速、流暢，沒有傳統多頁應用的白畫面等待時間。</li><li><strong>伺服器負擔小</strong>：伺服器只需提供靜態資源和 API，渲染工作交給客戶端，減輕了伺服器壓力。</li><li><strong>前後端分離</strong>：開發模式清晰，前端專注於 UI&#x2F;UX，後端專注於 API，方便團隊協作。</li></ul><h3 id="SPA-缺點"><a href="#SPA-缺點" class="headerlink" title="SPA 缺點"></a>SPA 缺點</h3><ul><li>**首次載入速度慢 (FCP 慢)**：需要下載完整的 JavaScript 檔案後才能渲染頁面，導致使用者看到畫面的時間（First Contentful Paint）較長。</li><li><strong>SEO 不佳</strong>：搜尋引擎爬蟲可能無法正確執行 JavaScript，導致抓取到的頁面是空白的，不利於搜尋引擎排名。雖然現在 Google 爬蟲已經能更好地處理 JavaScript，但這仍然是一個潛在問題。</li></ul><h2 id="SSR-Server-Side-Rendering"><a href="#SSR-Server-Side-Rendering" class="headerlink" title="SSR (Server-Side Rendering)"></a>SSR (Server-Side Rendering)</h2><p>為了解決 SPA 的問題，SSR 應運而生。Nuxt3 和 Next.js 這類框架讓 SSR 的實作變得更加簡單。</p><h3 id="SSR-運作方式"><a href="#SSR-運作方式" class="headerlink" title="SSR 運作方式"></a>SSR 運作方式</h3><ol><li><strong>初始請求</strong>：瀏覽器向伺服器請求頁面。</li><li><strong>伺服器端渲染</strong>：伺服器接收到請求後，會在後端環境（如 Node.js）執行前端框架的程式碼，將對應的頁面元件渲染成完整的 HTML 字串。</li><li><strong>回傳 HTML</strong>：伺服器將渲染好的 HTML 回傳給瀏覽器。</li><li>**Hydration (注水)**：瀏覽器顯示 HTML 內容後，會接著下載 JavaScript 檔案。JS 執行後會將事件監聽器、狀態等附加到現有的 DOM 上，讓頁面變成一個可互動的 SPA。這個過程稱為 “Hydration”。</li></ol><h3 id="SSR-優點"><a href="#SSR-優點" class="headerlink" title="SSR 優點"></a>SSR 優點</h3><ul><li>**首次載入速度快 (FCP 快)**：瀏覽器直接接收到完整的 HTML，可以立即顯示內容，使用者能更快看到頁面。</li><li><strong>SEO 友善</strong>：回傳給爬蟲的是完整的 HTML，有利於搜尋引擎索引。</li></ul><h3 id="SSR-缺點"><a href="#SSR-缺點" class="headerlink" title="SSR 缺點"></a>SSR 缺點</h3><ul><li><strong>伺服器負擔大</strong>：每個請求都需要在伺服器上即時渲染，對伺服器造成較大壓力。</li><li><strong>開發複雜度高</strong>：需要考慮程式碼在伺服器和客戶端兩種環境下的執行情況，例如 <code>window</code>、<code>document</code> 等瀏覽器專屬的 API 只能在客戶端使用。</li></ul><h2 id="SSG-Static-Site-Generation"><a href="#SSG-Static-Site-Generation" class="headerlink" title="SSG (Static Site Generation)"></a>SSG (Static Site Generation)</h2><p>SSG 結合了 SSR 和 SPA 的部分優點，它在「建置階段」就產生所有頁面的靜態 HTML 檔案。</p><h3 id="SSG-運作方式"><a href="#SSG-運作方式" class="headerlink" title="SSG 運作方式"></a>SSG 運作方式</h3><ol><li><strong>建置階段</strong>：在部署前，透過框架的 <code>build</code> 指令，抓取所有需要的資料，並為每個頁面產生一個對應的 HTML 檔案。</li><li><strong>部署</strong>：將這些產生的靜態檔案（HTML, CSS, JS）部署到任何靜態網站託管服務上，例如 GitHub Pages, Netlify, Vercel 或 CDN。</li><li><strong>使用者請求</strong>：使用者請求頁面時，伺服器直接回傳對應的靜態 HTML 檔案，無需任何後端渲染。</li></ol><h3 id="SSG-優點"><a href="#SSG-優點" class="headerlink" title="SSG 優點"></a>SSG 優點</h3><ul><li><strong>效能極致</strong>：因為頁面是預先渲染好的，回應速度最快。</li><li><strong>安全性高</strong>：沒有後端資料庫或即時渲染邏輯，減少了被攻擊的風險。</li><li><strong>成本低廉</strong>：可以部署在便宜甚至免費的靜態託管服務上。</li><li><strong>SEO 友善</strong>：與 SSR 一樣，提供完整的 HTML 內容。</li></ul><h3 id="SSG-缺點"><a href="#SSG-缺點" class="headerlink" title="SSG 缺點"></a>SSG 缺點</h3><ul><li><strong>更新延遲</strong>：如果網站內容頻繁變動（例如新聞網站、論壇），每次更新都需要重新建置整個網站，可能耗時較長。</li><li><strong>不適用於動態內容</strong>：不適合需要根據使用者互動即時產生內容的頁面（例如個人化儀表板）。</li></ul><h2 id="Nuxt3-中的渲染模式"><a href="#Nuxt3-中的渲染模式" class="headerlink" title="Nuxt3 中的渲染模式"></a>Nuxt3 中的渲染模式</h2><p>Nuxt3 提供了靈活的設定，讓你可以輕鬆在這些模式之間切換：</p><ul><li>**通用渲染 (Universal Rendering)**：預設模式，結合了 SSR（首次載入）和 CSR（後續導航）。</li><li>**客戶端渲染 (CSR&#x2F;SPA)**：在 <code>nuxt.config.ts</code> 中設定 <code>ssr: false</code> 即可切換為 SPA 模式。</li><li>**靜態網站生成 (SSG)**：執行 <code>nuxi generate</code> 指令來建置專案，Nuxt 會為你的頁面產生靜態檔案。</li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><table><thead><tr><th align="left">特性</th><th align="left">SPA (CSR)</th><th align="left">SSR</th><th align="left">SSG</th></tr></thead><tbody><tr><td align="left"><strong>渲染位置</strong></td><td align="left">瀏覽器</td><td align="left">伺服器 (每次請求)</td><td align="left">伺服器 (建置時)</td></tr><tr><td align="left"><strong>首次載入速度</strong></td><td align="left">慢</td><td align="left">快</td><td align="left">最快</td></tr><tr><td align="left"><strong>SEO</strong></td><td align="left">差</td><td align="left">好</td><td align="left">好</td></tr><tr><td align="left"><strong>伺服器負擔</strong></td><td align="left">低</td><td align="left">高</td><td align="left">無 (靜態伺服器)</td></tr><tr><td align="left"><strong>適用場景</strong></td><td align="left">後台管理、Web 應用</td><td align="left">新聞、電商、內容網站</td><td align="left">部落格、文件、作品集</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在學習 Nuxt3，它是一個基於 Vue.js 的框架，提供了強大的功能來建構現代化的 Web 應用。其中最吸引我的就是它對不同渲染模式的支援，特別是伺服器端渲染（SSR）。在深入 Nuxt3 之前，我想先好好了解一下幾種常見的網頁渲染模式：SPA、SSR 和 SSG。這篇文章將會是我學習這幾個概念的筆記。&lt;/p&gt;
&lt;img src=&quot;/posts/Ssr-know/ssr1.webp&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="SSR" scheme="https://colinchiu87.github.io/tags/SSR/"/>
    
    <category term="SPA" scheme="https://colinchiu87.github.io/tags/SPA/"/>
    
    <category term="SSG" scheme="https://colinchiu87.github.io/tags/SSG/"/>
    
  </entry>
  
  <entry>
    <title>Npm vs Yarn vs Pnpm：哪個套件管理工具最適合你？</title>
    <link href="https://colinchiu87.github.io/posts/Other-nodePackageManagers/"/>
    <id>https://colinchiu87.github.io/posts/Other-nodePackageManagers/</id>
    <published>2025-03-10T13:28:19.000Z</published>
    <updated>2025-03-10T15:08:30.688Z</updated>
    
    <content type="html"><![CDATA[<img src="/posts/Other-nodePackageManagers/img1.png" class=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>寫 JavaScript 專案，免不了要裝各種套件，這時候就會遇到三大門派：</p><ul><li>npm，元老級選手，江湖地位穩固，但過去偶爾會「手滑」刪掉 node_modules 🙃</li><li>Yarn，帶著「速度更快、更可靠」的標語橫空出世，結果後來自己也改版改到讓人眼花撩亂 🤯</li><li>pnpm，號稱「不重複裝套件」，省空間又省時間，硬是要來顛覆傳統 💾💨</li></ul><p>到底誰才是你的最佳選擇？這篇文章會帶你一探究竟，看看誰能成為你的專案好夥伴！</p><span id="more"></span><h2 id="淺談我們耳熟能詳的-NPM"><a href="#淺談我們耳熟能詳的-NPM" class="headerlink" title="淺談我們耳熟能詳的 NPM"></a>淺談我們耳熟能詳的 NPM</h2><p>NPM 全名為 Node Package Manager，是個被廣用的 JavaScript 套件管理工具。讓我們開發者能夠輕鬆地安裝、共享、管理依賴庫和應用程式。搭配著 package.json 所詳細描述各個項目的版本資訊，及相關指令。</p><h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><h3 id="Yarn-1-x"><a href="#Yarn-1-x" class="headerlink" title="Yarn 1.x"></a>Yarn 1.x</h3><p>是在 2016 年由 Facebook 推出，為求更好的性能及安全性。雖然與 npm 都是 package manager，但是 yarn 有的是更快的性能及增強的安全性，還有一個特點：支持單一儲存庫的工作區。不需要擔心的是它與 npm 和 bower 相容，同時也支援不同的套件庫（registry），而指令也與 npm 相同或相似。只不過聲稱速度上優勢，但 npm 所具備的缺點還是無可避免地存在…</p><h3 id="Yarn-2-x"><a href="#Yarn-2-x" class="headerlink" title="Yarn 2.x"></a>Yarn 2.x</h3><p>儘管 Yarn 可以有效解決 NPM 的問題，但仍然是基於 NPM 的框架所開發，所以有了全新的開始 Yarn 2 的出生。你可能也有聽過 Yarn Modern, Yarn Berry 這些都泛指 Yarn 2.0 後的版本，用來區別原先的 Yarn Classic v1.x。注意：舊版本至從 Yarn 2 誕生後，將不再維護！</p><h3 id="Plug’n’Play"><a href="#Plug’n’Play" class="headerlink" title="Plug’n’Play"></a>Plug’n’Play</h3><p>執行 yarn install 後，將檔案存入專案的 .yarn&#x2F;cache 中，省去 node_modules Link 的複雜 I&#x2F;O 流程，並個別壓縮形成 .zip，因此空間減少了也能一起上傳至遠端管理，達成 Zero-Installs，確保建置在不同環境中都一致，大大的使多人協作的專案舒舒服服。</p><h2 id="Pnpm"><a href="#Pnpm" class="headerlink" title="Pnpm"></a>Pnpm</h2><p>因為他優秀的時間維度及空間維度的效率，讓他在官網上自稱 Fast, disk space efficient package manager。幾個與其他前輩的不同之處：</p><ul><li>在共享依賴時使用的是符號連結（Symbolic Links）</li><li>預設全局儲存一次相同依賴</li><li>所有的專案 node_modules 中並不會真實的複製依賴，而是用指向到全局儲存</li><li>安裝速度因為使用符號連結和全局緩存所以想比前輩是快得多</li><li>嚴格的依賴樹（strict dependency tree）避免了幽靈依賴的潛在問題</li></ul><h2 id="Npm-近年來補齊的-Yarn-優勢"><a href="#Npm-近年來補齊的-Yarn-優勢" class="headerlink" title="Npm 近年來補齊的 Yarn 優勢"></a>Npm 近年來補齊的 Yarn 優勢</h2><img src="/posts/Other-nodePackageManagers/img2.png" class=""><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>npm 現在幾乎補齊了 Yarn 1 的所有優勢，甚至在 audit（安全性）等方面表現更好。<br>如果你只需要 標準的套件管理，npm 現在已經完全夠用了！</p><p>但如果你考慮效能、磁碟使用最佳化等，那 pnpm 可能才是更值得關注的選擇！ 🚀</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/posts/Other-nodePackageManagers/img1.png&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;寫 JavaScript 專案，免不了要裝各種套件，這時候就會遇到三大門派：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm，元老級選手，江湖地位穩固，但過去偶爾會「手滑」刪掉 node_modules 🙃&lt;/li&gt;
&lt;li&gt;Yarn，帶著「速度更快、更可靠」的標語橫空出世，結果後來自己也改版改到讓人眼花撩亂 🤯&lt;/li&gt;
&lt;li&gt;pnpm，號稱「不重複裝套件」，省空間又省時間，硬是要來顛覆傳統 💾💨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到底誰才是你的最佳選擇？這篇文章會帶你一探究竟，看看誰能成為你的專案好夥伴！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Npm" scheme="https://colinchiu87.github.io/tags/Npm/"/>
    
    <category term="Yarn" scheme="https://colinchiu87.github.io/tags/Yarn/"/>
    
    <category term="Pnpm" scheme="https://colinchiu87.github.io/tags/Pnpm/"/>
    
  </entry>
  
  <entry>
    <title>Html-pictureTag</title>
    <link href="https://colinchiu87.github.io/posts/Html-pictureTag/"/>
    <id>https://colinchiu87.github.io/posts/Html-pictureTag/</id>
    <published>2025-01-05T10:35:59.000Z</published>
    <updated>2025-03-10T12:46:46.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hi, 假日好各位。剛剛在閱歷其他平凡俗子的生活時(俗稱滑手機)，看到人家的 html 中使用了 picture 的 tag，還想說這個人自創標籤超酷的，搜尋之下才自知井底之蛙…，我從來就只會用 <code>&lt;img&gt;</code> 呀!</p><img src="/posts/Html-pictureTag/1.jpg" class=""><span id="more"></span><h2 id="什麼是-picture-標籤"><a href="#什麼是-picture-標籤" class="headerlink" title="什麼是 picture 標籤"></a>什麼是 picture 標籤</h2><p>就一般顯示圖片而言，不太需要分太多種情況，所以直接使用 img 標籤是最快最輕便的；而當我們需要針對螢幕尺寸、圖片格式、解析度等等的需求，則建議可以使用 picture 來做開發。</p><p>picture 本身是沒有屬性設定的，需要設定的是在其中的 <code>&lt;source&gt;</code> 裡面</p><ul><li>media: 指定 media query 條件，如不符合就執行下一個。</li><li>srcset: 指定單張或多張不同尺寸圖片。</li><li>type: 指定圖檔的格式 (webp, jpg, png…)，如不符合就執行下一個。</li></ul><p>話不多說我們進實作 ▶</p><h3 id="img-tag-demo"><a href="#img-tag-demo" class="headerlink" title="img-tag demo"></a>img-tag demo</h3><iframe src="https://codepen.io/colinchiu87/embed/GgKPzoJ?default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><h3 id="picture-tag-demo"><a href="#picture-tag-demo" class="headerlink" title="picture-tag demo"></a>picture-tag demo</h3><p>這邊的範例是依照畫面寬度去調整顯示的圖片，從 400px 的小火龍 -&gt; 800px 的火恐龍 -&gt; 1200px 的噴火龍。(你可以切換 Result 下方的 1x 0.5x 0.25x 來看變化)<br>最後在添加一個預備 <code>&lt;img&gt;</code>，當瀏覽器不支援 <code>&lt;picture&gt;</code> 或沒有匹配到 source 條件時會顯示，而寫在 img 中的樣式都會套用到所有圖片中。</p><iframe src="https://codepen.io/colinchiu87/embed/emObaWK?default-tab=html,result" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ul><li>優先使用 <code>&lt;img&gt;</code>，除非有響應式或多格式需求。</li><li>如果需要針對不同設備、解析度或瀏覽器條件進行圖片優化，使用 <code>&lt;picture&gt;</code> 是最佳選擇。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hi, 假日好各位。剛剛在閱歷其他平凡俗子的生活時(俗稱滑手機)，看到人家的 html 中使用了 picture 的 tag，還想說這個人自創標籤超酷的，搜尋之下才自知井底之蛙…，我從來就只會用 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 呀!&lt;/p&gt;
&lt;img src=&quot;/posts/Html-pictureTag/1.jpg&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="html" scheme="https://colinchiu87.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>『Git』怎麼寫 Commit Message 更好</title>
    <link href="https://colinchiu87.github.io/posts/Git-commitMessage/"/>
    <id>https://colinchiu87.github.io/posts/Git-commitMessage/</id>
    <published>2024-06-10T07:25:04.000Z</published>
    <updated>2024-07-13T10:03:40.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前在開發的時候，總覺得沒有人會去看 git commit 的訊息，所以總是想寫什麼就寫什麼。<br>雖然都會標記一下[類型]：新增功能、刪除…之類的，但是真的超陽春。<br>直到最近，開始幫人家 Review code，才渴望人家的 Commit Message 可以留完整一點給我！</p><p>真心建議大家，早點培養起 commit message 良好習慣就越好！</p><img src="/posts/Git-commitMessage/gitMessage1.jpeg" class=""><span id="more"></span><h2 id="Better-git-commit-message"><a href="#Better-git-commit-message" class="headerlink" title="Better git commit message"></a>Better git commit message</h2><h3 id="為什麼應該要學習更好的-commit-message-撰寫？"><a href="#為什麼應該要學習更好的-commit-message-撰寫？" class="headerlink" title="為什麼應該要學習更好的 commit message 撰寫？"></a>為什麼應該要學習更好的 commit message 撰寫？</h3><p>第一步，打開手邊的專案並且查看 git log。<br>我相信絕大多數的人，肯定看不懂六個月前自己的 commit 到底對哪裡進行調整、原因是為什麼。</p><p>在你的 Coding 生涯中，或多或少有遇過沒有程式碼註解、沒有文件、沒有可追溯的歷史紀錄，這個時候你就必須要花上多幾倍的時間成本來完成原本的需求，又或者出現類似這樣的問題：我如果刪除了這一行會不會讓程式不會跑？</p><h3 id="展望未來"><a href="#展望未來" class="headerlink" title="展望未來"></a>展望未來</h3><p>撰寫優秀的 Commit，就是節省了你或者你的同事未來尋找 bug 的時間。在開發之餘，花點時間去寫一封提交訊息給未來的自己，是非常值得的，尤其在大型的專案中，任何有關的文件都至關重要。</p><p>我強烈建議，在開發團隊中，如果還沒有建立起提交訊息的相關規範，就立即行動吧！</p><h3 id="比起你做了什麼，別人更想知道你為什麼做"><a href="#比起你做了什麼，別人更想知道你為什麼做" class="headerlink" title="比起你做了什麼，別人更想知道你為什麼做"></a>比起你做了什麼，別人更想知道你為什麼做</h3><p>這句話，是我有一天滑手機時無意間看到的，但印象很深刻。<br>你做了什麼，只要看 changed files 就可以知道了，而你因為什麼而做卻看不出來。<br>如果你要寫 message 時，不妨這樣思考，會有幫助的。</p><h2 id="幾個要點寫出好的提交訊息"><a href="#幾個要點寫出好的提交訊息" class="headerlink" title="幾個要點寫出好的提交訊息"></a>幾個要點寫出好的提交訊息</h2><ol><li>Commit type: 使用特定的類型來表示，可以讓人第一眼就分辨出這是什麼樣類別的提交。</li><li>Length: 適當的長度會讓人感覺到用字精準，通常第一行不會超過 20 個字，並且不會使用標點符號及大寫字母，內容限制在 72 個字。</li><li>Content: 所有的句子都要直接，盡量避免使用太多的連接詞，例如：雖然、也許、我認為、有點…</li></ol><p>知道規範後，要如何生產出內容呢？問自己以下幾個問題，並串接起來，就會豁然開朗：</p><ul><li>我為什麼要做這個變更？</li><li>我做的這些改變會有什麼影響？</li><li>為什麼需要做這些改變？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;add margin&#x27;</span><br><span class="line"></span><br><span class="line">git commit -m &#x27;add margin to product items to prevent them from overlapping&#x27;</span><br></pre></td></tr></table></figure><p>這邊偷偷透露，我以前真的都寫第一種的提交訊息 😂</p><h2 id="常用的-Commit-Type"><a href="#常用的-Commit-Type" class="headerlink" title="常用的 Commit Type"></a>常用的 Commit Type</h2><img src="/posts/Git-commitMessage/gitMessage2.webp" class=""><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>撰寫出色的提交，能幫助整個團隊的溝通及協作。Commit message 是專案的修改歷史，幫助我們解讀過去並在未來做出合理的決定。<br>希望閱讀完本篇的你，有被幫助提升 Commit 的品質。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;以前在開發的時候，總覺得沒有人會去看 git commit 的訊息，所以總是想寫什麼就寫什麼。&lt;br&gt;雖然都會標記一下[類型]：新增功能、刪除…之類的，但是真的超陽春。&lt;br&gt;直到最近，開始幫人家 Review code，才渴望人家的 Commit Message 可以留完整一點給我！&lt;/p&gt;
&lt;p&gt;真心建議大家，早點培養起 commit message 良好習慣就越好！&lt;/p&gt;
&lt;img src=&quot;/posts/Git-commitMessage/gitMessage1.jpeg&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://colinchiu87.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>震驚！使用這一個方法解放你的手機容量 - iCloud 共享相簿</title>
    <link href="https://colinchiu87.github.io/posts/Iphone-sharedAlbum/"/>
    <id>https://colinchiu87.github.io/posts/Iphone-sharedAlbum/</id>
    <published>2024-05-26T03:06:25.000Z</published>
    <updated>2024-05-26T10:03:22.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本想學一下現在的新聞聳動標題，但這樣怎麼 SEO 拉 🤣<br>你是不是每隔一段時間就會收到手機容量快滿的通知？<br>現在手機的容量根本就滿足不了我們小網美，就只能準備一顆硬碟或者訂閱雲端容量。<br>我在這邊正式宣布果粉有福了(<del>功能早就出了</del></p><img src="/posts/Iphone-sharedAlbum/sharedAlbum12.png" class=""><span id="more"></span><h2 id="iCloud-共享相簿"><a href="#iCloud-共享相簿" class="headerlink" title="iCloud 共享相簿"></a>iCloud 共享相簿</h2><p>如其名，一個可以跟其他人一起共同編輯的相簿。在 iCloud 上建立，可以隨時隨地上傳和查看，而且還++不會占用的你任何儲存空間++(❌iCloud❌ 手機容量)，最後還能控制誰可查看或下載。</p><h3 id="如何建立-iCloud-共享相簿？"><a href="#如何建立-iCloud-共享相簿？" class="headerlink" title="如何建立 iCloud 共享相簿？"></a>如何建立 iCloud 共享相簿？</h3><ol><li>確認自己的 Iphone 有沒有開啟該功能。</li></ol><img src="/posts/Iphone-sharedAlbum/sharedAlbum1.png" class=""><ol start="2"><li>建立一個共享相簿，並加入要分享的照片 or 影片。</li></ol><img src="/posts/Iphone-sharedAlbum/sharedAlbum2.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum3.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum4.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum5.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum6.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum7.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum8.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum9.jpg" class=""><ol start="3"><li>邀請朋友、家人訂閱相簿。</li></ol><img src="/posts/Iphone-sharedAlbum/sharedAlbum10.jpg" class=""><img src="/posts/Iphone-sharedAlbum/sharedAlbum11.jpg" class=""><h3 id="有甚麼限制嗎？"><a href="#有甚麼限制嗎？" class="headerlink" title="有甚麼限制嗎？"></a>有甚麼限制嗎？</h3><p>雖然這些相簿不會計入你的 iCloud 儲存空間，但你可以共享的照片及影片、邀請都有數量的限制。</p><ul><li><p>單一協作人每小時上傳到所有共享相簿中的照片和影片數量上限：1000</p></li><li><p>單一協作人每天上傳到所有共享相簿中的照片和影片數量上限：10,000</p></li><li><p>持有人可分享的共享相簿數量上限：200</p></li><li><p>使用者可訂閱的共享相簿數量上限：200</p></li><li><p>每個共享相簿的訂閱者數量上限：100（每個共享相簿的訂閱者數量）</p></li><li><p>任一共享相簿中所有提供者的照片和影片總數上限：5000</p></li><li><p>共享相簿中每張照片或每部影片的評論數量上限：200（評論可以是喜歡或文字項目）</p></li><li><p>每則評論的字元數上限：1024</p></li><li><p>共享相簿持有人每天可傳送的邀請數量上限：200</p></li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這樣一個分享照片的空間，已經算是非常足夠我們平民老百姓使用了，甚至還可以點讚、評論 XD<br>只是在最後提醒一下各位，盡量不要使用共享相簿當成你自己的資料備份，還是有機會會憑空消失的，當然不重要的資料就直接解放你設備的空間吧！<br>希望大家喜歡這次的分享，我們下次見 ☺</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>圖片皆取自 Google<br><span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS96aC10dy8xMDgzMTQ=">Apple官方連結 - 共享相簿<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本想學一下現在的新聞聳動標題，但這樣怎麼 SEO 拉 🤣&lt;br&gt;你是不是每隔一段時間就會收到手機容量快滿的通知？&lt;br&gt;現在手機的容量根本就滿足不了我們小網美，就只能準備一顆硬碟或者訂閱雲端容量。&lt;br&gt;我在這邊正式宣布果粉有福了(&lt;del&gt;功能早就出了&lt;/del&gt;&lt;/p&gt;
&lt;img src=&quot;/posts/Iphone-sharedAlbum/sharedAlbum12.png&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="IPhone" scheme="https://colinchiu87.github.io/tags/IPhone/"/>
    
  </entry>
  
  <entry>
    <title>敏捷式開發真的這麼棒？</title>
    <link href="https://colinchiu87.github.io/posts/Other-agile/"/>
    <id>https://colinchiu87.github.io/posts/Other-agile/</id>
    <published>2024-03-09T06:23:02.000Z</published>
    <updated>2024-03-09T06:55:24.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在正式開始之前，我們先知道什麼是【瀑布式開發】，這也是一般專案團隊最常用的開發方式。</p><img src="/posts/Other-agile/agile1.png" class=""><p>如圖所示，每隔階段定義的十分清楚，要執行的項目明確。就像瀑布一樣，一路向下前行。實際在開發的時候，成員也都樂於這樣的模式，因為不會遇到模糊不清的時候(Ex 需求不知道是什麼就要進行開發… &#x3D; &#x3D;)。這在專案管理上是相對容易的，過程不會遲疑，檢視最後的成果是不是有達成目標就行。</p><span id="more"></span><p>但是，弊端也顯而易見。執行專案時，總是會有意外、風險、市場變化…，這些都是不可被預測的，而當專案是瀑布式開發，對於以上的變因，應對過慢，就很容易導致專案失敗！</p><blockquote><p>瀑布式開發，強調的是「工具」、「流程」。<br>敏捷式開發，強調的是「個人」、「互動」、「變化」。</p></blockquote><h2 id="敏捷式開發"><a href="#敏捷式開發" class="headerlink" title="敏捷式開發"></a>敏捷式開發</h2><h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p><span class="exturl" data-url="aHR0cHM6Ly9hZ2lsZW1hbmlmZXN0by5vcmcvaXNvL3poY2h0L21hbmlmZXN0by5odG1s">《敏捷軟體開發宣言》<i class="fa fa-external-link-alt"></i></span> 裡頭說：</p><ul><li><strong>個人與互動</strong> 重於 流程與工具</li><li><strong>可用的軟體</strong> 重於 詳盡的文件</li><li><strong>與客戶合作</strong> 重於 合約協商</li><li><strong>回應變化</strong> 重於 遵循計畫</li></ul><p>從中知道，敏捷式開發注重的是溝通、成果、合作與變化。</p><blockquote><p>「變」是唯一不變的事情</p></blockquote><h3 id="Scrum框架"><a href="#Scrum框架" class="headerlink" title="Scrum框架"></a>Scrum框架</h3><p>我們耳熟能詳的 Scrum 就是實現敏捷開發的其中一種方式，也是最被廣泛運用的框架。</p><p>為達到相對短的開發週期，可能會抓大概 2 - 4 周，依據產品和團隊的不同，週期也會不同。而這個週期稱之為「Sprint」。</p><p>每一個 Sprint 中，會有四個會議：</p><ol><li>規劃：決定要完成哪些項目</li><li>每日站立：每日花費10-15mins 同步資訊 (昨日完成、今日預計完成、是否遇到阻礙)</li><li>審查：展示成果，取得回饋、新需求</li><li>回顧：回顧衝刺的過程，是否有地方要改進</li></ol><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3> <img src="/posts/Other-agile/agile2.png" class=""><ul><li>產品負責人 (Product Owner)<br>代表客戶的意願，並確保團隊在做從業務角度來說正確的事情。編寫 User story，排出優先級，並放入 代辦清單(backlog)。他決定每一次 sprint 要完成哪些任務，讓整個團隊價值最大化。監督開發的節奏，從而保障產品的品質。</li></ul> <img src="/posts/Other-agile/agile3.png" class=""><ul><li>Scrum主管 (Scrum Master)<br>主要的工作是去除影響團隊達成 sprint 目標的障礙，是規則的執行者。</li></ul> <img src="/posts/Other-agile/agile4.png" class=""><ul><li>開發團隊 (Dev Team)<br>負責交付產品的團隊。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>沒有一定比較好的 development，還是要依照專案需求、公司文化…來做選擇。各有各的優勢在，不過在快速變化的商業環境和技術環境中，迎接變化能力強的敏捷式開發原則，的確是可以滿足現況。<br>祝福大家都不要碰到四不像的敏捷開發😆</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在正式開始之前，我們先知道什麼是【瀑布式開發】，這也是一般專案團隊最常用的開發方式。&lt;/p&gt;
&lt;img src=&quot;/posts/Other-agile/agile1.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;如圖所示，每隔階段定義的十分清楚，要執行的項目明確。就像瀑布一樣，一路向下前行。實際在開發的時候，成員也都樂於這樣的模式，因為不會遇到模糊不清的時候(Ex 需求不知道是什麼就要進行開發… &amp;#x3D; &amp;#x3D;)。這在專案管理上是相對容易的，過程不會遲疑，檢視最後的成果是不是有達成目標就行。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Agile Development" scheme="https://colinchiu87.github.io/tags/Agile-Development/"/>
    
  </entry>
  
  <entry>
    <title>Day.js 將取代 Moment.js？</title>
    <link href="https://colinchiu87.github.io/posts/Js-dayjs/"/>
    <id>https://colinchiu87.github.io/posts/Js-dayjs/</id>
    <published>2024-03-09T05:42:39.000Z</published>
    <updated>2024-03-09T06:05:43.673Z</updated>
    
    <content type="html"><![CDATA[<img src="/posts/Js-dayjs/dayjs-logo.png" class=""><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開發專案的時候，遇到與時間有關的地方，你會想到甚麼語法？套件？<br>不得不承認，我浮現在腦袋的第一個東西就是 moment.js 的套件，你是不是也是這樣XD<br>它是最古老、最受歡迎的 Library ，在關鍵字搜尋也是優先會看到的。</p><p>但，<em>如果遲遲不放下過去，就抵達不了未來</em>。</p><span id="more"></span><h2 id="比較"><a href="#比較" class="headerlink" title="比較"></a>比較</h2><p>這邊就直接暴雷，告訴大家為什麼可以考慮使用 Day.js。</p><ul><li>Package 輕量：為了不要跟原生 Date 比起來造成太大負擔，走一個輕薄短小的風格，可以引入基本核心的功能，額外的功能再搭配 plugins 處理。</li><li>Api 淺顯易懂：因為都是返回 Day.js 物件，因此可以串接(<strong>chainable</strong>)</li><li>Immutable：每個 API 都回傳全新的 Day.js 物件，而非修改物件本身，避免 side effect 造成 bug</li></ul><img src="/posts/Js-dayjs/img1.webp" class=""><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>你也不要覺得替換一個習慣是個很麻煩的事，因為！</p><p><strong>使用方法幾乎都是和 momentJs 相同的</strong></p><p>最後，DayJs 還有許多客製化和 i18n 的用法，就讓大家去摸索吧！</p><p><span class="exturl" data-url="aHR0cHM6Ly9kYXkuanMub3JnL2VuLw==">官方文件ㄉ連結<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/posts/Js-dayjs/dayjs-logo.png&quot; class=&quot;&quot;&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在開發專案的時候，遇到與時間有關的地方，你會想到甚麼語法？套件？&lt;br&gt;不得不承認，我浮現在腦袋的第一個東西就是 moment.js 的套件，你是不是也是這樣XD&lt;br&gt;它是最古老、最受歡迎的 Library ，在關鍵字搜尋也是優先會看到的。&lt;/p&gt;
&lt;p&gt;但，&lt;em&gt;如果遲遲不放下過去，就抵達不了未來&lt;/em&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
    <category term="Library" scheme="https://colinchiu87.github.io/tags/Library/"/>
    
  </entry>
  
  <entry>
    <title>動態規劃 Dynamic Programming</title>
    <link href="https://colinchiu87.github.io/posts/Algorithm-dynamicProgramming/"/>
    <id>https://colinchiu87.github.io/posts/Algorithm-dynamicProgramming/</id>
    <published>2023-08-29T11:21:09.000Z</published>
    <updated>2024-03-09T05:41:07.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小明是一名熱愛解決難題的大學生，他正在參加一個程式比賽。這次比賽有一道題目是關於動態規劃法的，要求參賽者找到一個數列中最大的連續子數列和。</p><img src="/posts/Algorithm-dynamicProgramming/img2.jpeg" class=""><span id="more"></span><h2 id="動態規劃法"><a href="#動態規劃法" class="headerlink" title="動態規劃法"></a>動態規劃法</h2><p>這邊先記幾個關鍵字 “儲存”,”小問題”,”組合”,”大問題”。所以基本上一個問題假如能符合以下就可以使用動態規劃來思考。</p><ul><li>可以拆成很多小問題</li><li>答案可以透過組合小問題來解</li><li>小問題重覆量很高</li></ul><img src="/posts/Algorithm-dynamicProgramming/img3.webp" class=""><img src="/posts/Algorithm-dynamicProgramming/img4.webp" class=""><p>我個人研究出當有提到 <code>subarray</code>、<code>subsequence</code> 的時候也可能會使用到動態規劃。</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>就延續前言的故事，來解最大子數列和吧！<br>稍微說明一下題目：在一維的數列中，要找出連續的子數列，且該子數列的和是最大。</p><p><code>array = [−2, 1, −3, 4, −1, 2, 1, −5, 4]</code></p><h4 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h4><p>最直覺的做法，就是直接寫一個雙層迴圈，跑完所有子數列，比較總和大小，就得出答案了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMaxSubarray</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> finalMax = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;array.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j&lt;array.<span class="property">length</span>; j++)&#123;</span><br><span class="line">      currentMax +=  array[j];</span><br><span class="line">      <span class="keyword">if</span> (currentMax &gt; finalMax) &#123;</span><br><span class="line">        finalMax = currentMax;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> finalMax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，也附上 Wiki 的網址可以參考 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JTkwJUU2JUIzJUEyJUU5JTgyJUEzJUU1JUE1JTkxJUU2JTk1JUIw">連結在此<i class="fa fa-external-link-alt"></i></span></p><h2 id="與貪婪演算法"><a href="#與貪婪演算法" class="headerlink" title="與貪婪演算法"></a>與貪婪演算法</h2><p>總的來說，貪婪演算法和動態規劃算法都是求解最優化問題的重要算法。選擇哪種算法取決於問題的性質和細節，以及算法的效率和準確性要求。對於某些問題，貪婪演算法可能會得到次優解或不可行解，而動態規劃算法可以得到最優解；但是對於某些問題，貪婪演算法的效率更高，而動態規劃算法需要額外的空間和時間來求解。因此，在選擇算法時，需要根據問題的特點和要求來選擇適合的算法。</p><h2 id="有關動態規劃的題目"><a href="#有關動態規劃的題目" class="headerlink" title="有關動態規劃的題目"></a>有關動態規劃的題目</h2><ul><li>斐波那契數列</li><li>連續子數列最大和 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheQ==">Leet Code 53<i class="fa fa-external-link-alt"></i></span></li><li>連續子數列最大乘積 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1wcm9kdWN0LXN1YmFycmF5">Leet Code 152<i class="fa fa-external-link-alt"></i></span></li><li>最長遞增子數列 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2U=">Leet Code 1143<i class="fa fa-external-link-alt"></i></span></li><li>數組數列中，最長子數列 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGlzdGluY3Qtc3Vic2VxdWVuY2Vz">Leet Code 115<i class="fa fa-external-link-alt"></i></span></li></ul><blockquote><p>以上圖片下載自google</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;小明是一名熱愛解決難題的大學生，他正在參加一個程式比賽。這次比賽有一道題目是關於動態規劃法的，要求參賽者找到一個數列中最大的連續子數列和。&lt;/p&gt;
&lt;img src=&quot;/posts/Algorithm-dynamicProgramming/img2.jpeg&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="Algorithm" scheme="https://colinchiu87.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>『小技巧』VSCode 多開視窗（同專案）</title>
    <link href="https://colinchiu87.github.io/posts/Skill-VSCode-multipleWindow/"/>
    <id>https://colinchiu87.github.io/posts/Skill-VSCode-multipleWindow/</id>
    <published>2023-08-22T11:13:29.000Z</published>
    <updated>2024-05-26T04:12:39.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>麥可是一名富有創造力的工程師，他在一家科技公司工作，負責設計和開發新的產品原型。為了更有效地實現他的構想，他在自己的工作站上安裝了多個顯示器。這些螢幕允許他同時查看複雜的設計圖紙、程式碼和模擬結果，使他能夠快速地在不同的任務之間切換，並保持專注。</p><img src="/posts/Skill-VSCode-multipleWindow/img1.jpeg" class=""><span id="more"></span><h2 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h2><p>你也想要成為一位效率爆表的工程師嗎？</p><ol><li>打開你的 VSCode</li><li>Ctrl + Shift + P 開啟指令區 (masOS: Command + Shift + P)<img src="/posts/Skill-VSCode-multipleWindow/img2.png" class=""></li><li>輸入 <code>Workspace: Duplicate As Workspace in New Window</code></li></ol><p>恭喜你又變強了一點點。XD</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;麥可是一名富有創造力的工程師，他在一家科技公司工作，負責設計和開發新的產品原型。為了更有效地實現他的構想，他在自己的工作站上安裝了多個顯示器。這些螢幕允許他同時查看複雜的設計圖紙、程式碼和模擬結果，使他能夠快速地在不同的任務之間切換，並保持專注。&lt;/p&gt;
&lt;img src=&quot;/posts/Skill-VSCode-multipleWindow/img1.jpeg&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="VS Code" scheme="https://colinchiu87.github.io/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>貪婪演算法 Greedy Algorithm</title>
    <link href="https://colinchiu87.github.io/posts/Algorithm-greedy/"/>
    <id>https://colinchiu87.github.io/posts/Algorithm-greedy/</id>
    <published>2023-08-21T11:10:44.000Z</published>
    <updated>2023-08-29T11:21:20.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從前有個小村莊，村民們過著平靜而樸實的生活。然而，他們面臨一個困境：村莊周圍的土地資源有限，每位村民都想要在這些土地上種植作物和建造房屋。因此，土地的分配成了一個問題。</p><p>村莊的首領考慮到了這個問題，他決定請來了一位聰明的專家幫助他們找到一個公平的土地分配方案。這位專家告訴首領，他可以使用一種叫做「貪婪演算法」的方法來解決這個問題。</p><img src="/posts/Algorithm-greedy/img1.avif" class=""><span id="more"></span><h2 id="貪婪演算法"><a href="#貪婪演算法" class="headerlink" title="貪婪演算法"></a>貪婪演算法</h2><p>貪婪演算法（Greedy Algorithm）是一種求解最優化問題的方法，該方法在每一個步驟都選擇當前狀態下的最佳解，並希望通過這種方式最終能夠獲得全局最優解。</p><p>貪婪演算法通常用於求解最優化問題，例如最小生成樹、最短路徑、背包問題等。這些問題可以被描述為一個圖，其中節點代表問題中的元素，邊代表元素之間的關係，權重代表成本或價值。</p><p>貪婪演算法的核心思想是在每個步驟中選擇當前狀態下最佳的解決方案。貪婪演算法不考慮整體最優解，而是通過局部最優解的選擇，希望最終能夠獲得全局最優解。貪婪演算法通常比較簡單且高效，但不能保證一定能獲得最優解。</p><p>那麼回到前言所提的例子，專家建議首領這樣做：首先，從村莊周圍的土地中選擇一塊最大的空地，讓第一位村民在那裡種植作物。然後，在剩餘的土地中，再選擇下一塊最大的空地，讓第二位村民使用，以此類推，直到所有的村民都分到土地為止。</p><h2 id="可能引發的問題"><a href="#可能引發的問題" class="headerlink" title="可能引發的問題"></a>可能引發的問題</h2><p>聽取了專家的建議，開始實施這個方案。一開始，村民們對這種分配方法感到滿意，因為每個人都能獲得相對寬敞的土地。然而，隨著時間的推移，一些村民開始注意到一個問題：雖然他們每個人都有了自己的土地，但其中一些土地可能位於較遠的地點，不太適合種植作物，或者地勢較差。於是，他們開始嘗試交換土地，希望找到更好的選擇。</p><h2 id="零錢問題"><a href="#零錢問題" class="headerlink" title="零錢問題"></a>零錢問題</h2><img src="/posts/Algorithm-greedy/img3.png" class=""><p>像是這類可以利益最大化或是最佳解的的問題很常出現在日常生活中，畢竟大多時候人都是以利益最大化為出發點，思考著該怎麼做才會是最有利的，仔細想想，其實以人類的本性來說，無形之中我們應該用過不少次貪婪演算法了吧！</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>雖然貪婪演算法可以在短期內找到看似最佳的選擇，但它有時會忽略全局的信息，導致最終結果可能不盡如人意。<br>這個故事告訴我們，在解決問題時，我們需要考慮長遠的影響和全局的因素，而不僅僅是眼前的表面利益。</p><img src="/posts/Algorithm-greedy/img2.jfif" class="">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;從前有個小村莊，村民們過著平靜而樸實的生活。然而，他們面臨一個困境：村莊周圍的土地資源有限，每位村民都想要在這些土地上種植作物和建造房屋。因此，土地的分配成了一個問題。&lt;/p&gt;
&lt;p&gt;村莊的首領考慮到了這個問題，他決定請來了一位聰明的專家幫助他們找到一個公平的土地分配方案。這位專家告訴首領，他可以使用一種叫做「貪婪演算法」的方法來解決這個問題。&lt;/p&gt;
&lt;img src=&quot;/posts/Algorithm-greedy/img1.avif&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="Algorithm" scheme="https://colinchiu87.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』圖形 Graph</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-graph/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-graph/</id>
    <published>2023-07-17T13:15:14.000Z</published>
    <updated>2023-08-21T11:10:56.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好～ 在文章開始之前，我們先讓各位看一下名詞提要。</p><ul><li>頂點 Vertex or Node</li><li>邊 Edge：兩個頂點間的連線</li><li>無向性 Undirected：邊無方向性，表示兩點之間為雙向關係。 &#x2F; 有向性 Directed：邊有方向性，表示兩點之間為單向關係。</li><li>加權 Weighted：邊加上權重，代表兩點之間的關係；點加上權重，代表狀態</li></ul><p>以上都是我們在圖形這個章節會時常看到的名詞，那我們正是開始囉 GoGo。</p><span id="more"></span><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><ol><li>無向圖<img src="/posts/DataStructure-graph/graph1.png" class=""></li><li>有向圖<img src="/posts/DataStructure-graph/graph2.png" class=""></li><li>權重圖<img src="/posts/DataStructure-graph/graph3.png" class=""></li></ol><h2 id="圖形遍歷-Graph-Traversal"><a href="#圖形遍歷-Graph-Traversal" class="headerlink" title="圖形遍歷 Graph Traversal"></a>圖形遍歷 Graph Traversal</h2><h3 id="廣度搜尋-Breadth-First-Search"><a href="#廣度搜尋-Breadth-First-Search" class="headerlink" title="廣度搜尋 Breadth First Search"></a>廣度搜尋 Breadth First Search</h3><p>廣度優先的搜尋順序會是先走訪相鄰節點，都走訪完了，就往下一層繼續走訪，廣度優先搜尋採用queue來實作，因為queue具有先進先出的特性，可以確保先搜尋到的節點，會優先成為下一個搜尋起點。</p><img src="/posts/DataStructure-graph/graph4.png" class=""><p>程式範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnweightedGraph</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">neighbors</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">visited</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addNeighbor</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">neighbors</span>.<span class="title function_">push</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> B = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> C = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> D = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> E = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;E&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> F = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;F&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> G = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;G&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> H = <span class="keyword">new</span> <span class="title class_">UnweightedGraph</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">A.<span class="title function_">addNeighbor</span>(B);</span><br><span class="line">A.<span class="title function_">addNeighbor</span>(C);</span><br><span class="line">A.<span class="title function_">addNeighbor</span>(D);</span><br><span class="line">B.<span class="title function_">addNeighbor</span>(E);</span><br><span class="line">B.<span class="title function_">addNeighbor</span>(F);</span><br><span class="line">D.<span class="title function_">addNeighbor</span>(G);</span><br><span class="line">D.<span class="title function_">addNeighbor</span>(H);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">BFS</span> = (<span class="params">starter</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> queue = [],</span><br><span class="line">    result = [];</span><br><span class="line">  queue.<span class="title function_">push</span>(starter);</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> firstNode = queue.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="keyword">if</span> (!firstNode.<span class="property">visited</span>) &#123;</span><br><span class="line">    firstNode.<span class="property">visited</span> = <span class="literal">true</span>;</span><br><span class="line">        result.<span class="title function_">push</span>(firstNode.<span class="property">value</span>);</span><br><span class="line">        firstNode.<span class="property">neighbors</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!element.<span class="property">visited</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">BFS</span>(A);</span><br><span class="line"><span class="comment">//輸出結果 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="深度搜尋-Depth-First-Search"><a href="#深度搜尋-Depth-First-Search" class="headerlink" title="深度搜尋 Depth First Search"></a>深度搜尋 Depth First Search</h3><p>會先從一邊開始走訪，概念類似於走迷宮摸著牆走的概念，走到底了就折返，繼續往沒走過的節點探索</p><img src="/posts/DataStructure-graph/graph5.png" class=""><p>程式範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">DFT</span> = (<span class="params">starter</span>) =&gt; &#123;</span><br><span class="line">    starter.<span class="property">visited</span> = <span class="literal">true</span>;</span><br><span class="line">    result.<span class="title function_">push</span>(starter.<span class="property">value</span>);</span><br><span class="line">    starter.<span class="property">neighbors</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!element.<span class="property">visited</span>) <span class="title function_">DFT</span>(element);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">DFT</span>(A);</span><br><span class="line"></span><br><span class="line"><span class="comment">//輸出結果 [&quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;F&quot;, &quot;C&quot;, &quot;D&quot;, &quot;G&quot;, &quot;H&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="最短距離"><a href="#最短距離" class="headerlink" title="最短距離"></a>最短距離</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0B5aW5pbmcxMjA0LyVFNiVCQyU5NCVFNyVBRSU5NyVFNiVCMyU5NSVFNSU5QyU5NiVFOSU5MSU5MSVFOCVBRSU4MCVFNiU5QiVCOCVFNyVBRCU4NiVFOCVBOCU5OC0lRTclQUMlQUMlRTglODIlODYlRTclQUIlQTAtJUU1JTlDJTk2JUU1JUJEJUEyJUU2JTkwJTlDJUU1JUIwJThCLSVFNCVCOCVBRC02MWU5MTkwMzI5ZTA=">延伸一<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BhbWJlci5mcmFnbWVudHMvJUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1LSVFNSVBRCVCOCVFNyVCRiU5MiVFNyVBRCU4NiVFOCVBOCU5OC0xNC1kaWprc3RyYS1hbGdvcml0aG0tJUU2JTlDJTgwJUU3JTlGJUFEJUU4JUI3JUFGJUU1JUJFJTkxJUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1LTc0NTk4M2RkNDMzMg==">延伸二<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvYmVsbG1hbi1mb3JkLWFsZ29yaXRobS1kcC0yMy8=">延伸三<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大家好～ 在文章開始之前，我們先讓各位看一下名詞提要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂點 Vertex or Node&lt;/li&gt;
&lt;li&gt;邊 Edge：兩個頂點間的連線&lt;/li&gt;
&lt;li&gt;無向性 Undirected：邊無方向性，表示兩點之間為雙向關係。 &amp;#x2F; 有向性 Directed：邊有方向性，表示兩點之間為單向關係。&lt;/li&gt;
&lt;li&gt;加權 Weighted：邊加上權重，代表兩點之間的關係；點加上權重，代表狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上都是我們在圖形這個章節會時常看到的名詞，那我們正是開始囉 GoGo。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』字典和雜湊表 Dictionary and HashMap</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-dictionaryAndHashmap/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-dictionaryAndHashmap/</id>
    <published>2023-06-25T11:36:15.000Z</published>
    <updated>2023-07-17T12:48:38.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中的字典和雜湊表是非常有用的資料結構，可以用來快速查找鍵值對應的值。在 JavaScript 中，字典通常是用物件來實現，而雜湊表則可以使用 Map 來實現。這些資料結構非常常見，因此學習如何使用它們是很重要的。</p><p>順道提一下，集合(Set) [值：值]所關注的是值的本體，而字典(Dictionary)、雜湊表(HashMap) [鍵：值]關注的是兩者的 Mapping 關聯，這樣就可以簡單區分開來了。</p><p>在本篇文章中，我們將介紹如何在 JavaScript 中使用字典和雜湊表。我們將會討論它們的特性、如何使用它們來解決問題，以及它們的複雜度和效能。如果你對 JavaScript 的資料結構和算法感到興趣，這篇文章將會對你有所幫助。</p><span id="more"></span><h2 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 Dictionary"></a>字典 Dictionary</h2><p>想必大家都已經知道，集合代表的是一組互不重複的元素。在字典中，儲存的是「鍵：值」，鍵名用來查詢特定元素。<br>也稱作映射。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>set(key, value): 添加新的元素。</li><li>remove(key): 移除對應鍵值的元素。</li><li>has(key): 如果該鍵值存在此字典中，則回傳 true; 反之，回傳 false。</li><li>get(key): 利用鍵值尋找特定數值並回傳。</li><li>clear(): 清空此字典的所有元素。</li><li>size(): 返回字典所含的元素數量。</li><li>keys(): 回傳一個陣列，包含所有鍵。</li><li>values(): 回傳一個陣列，包含所有值。</li></ul><h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p>這次實作的類別是以 ECMAScript 6 中的 Map 做基礎。會明顯的發現和 Set 類別雷同。</p><h4 id="骨架"><a href="#骨架" class="headerlink" title="骨架"></a>骨架</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dictionary</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="has-set"><a href="#has-set" class="headerlink" title="has, set"></a>has, set</h4><p>第一步先建立 has, set 方法，而這邊會要先做 has()，是因為它會被 set, remove 其他的方法呼叫。<br>而 set(key, value)，可以用來添加一個新的值，或是將原有的值做更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">has</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> items;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">set</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">  items[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(key))&#123;</span><br><span class="line">    <span class="keyword">delete</span> items[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-values"><a href="#get-values" class="headerlink" title="get, values"></a>get, values</h4><p>如果想要在字典搜尋特定的一個元素，就可以使用 get 和 values。<br><code>values() 不能僅僅使用 for-in 遍歷整個 items 物件的屬性，還需要使用 has() 驗證是否包含該屬性。 因為物件的原型會含其它屬性在裡面( Js 基本的物件屬性是會被繼承的，並會存在當前的物件中 )</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> items)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(k))&#123;</span><br><span class="line">      values.<span class="title function_">push</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clear-size-keys-getItems"><a href="#clear-size-keys-getItems" class="headerlink" title="clear, size, keys, getItems"></a>clear, size, keys, getItems</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  items = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">keys</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">getItems</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Dictionary-類別-郵件通訊錄"><a href="#使用-Dictionary-類別-郵件通訊錄" class="headerlink" title="使用 Dictionary 類別 (郵件通訊錄)"></a>使用 Dictionary 類別 (郵件通訊錄)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> <span class="title class_">Dictionary</span>();</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Colin&#x27;</span>, <span class="string">&#x27;colin1225@email.com&#x27;</span>)</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;jake0305@email.com&#x27;</span>)</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Rick&#x27;</span>, <span class="string">&#x27;rick1010@email.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">has</span>(<span class="string">&#x27;Colin&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">size</span>()) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">keys</span>()) <span class="comment">// [&quot;Colin&quot;, &quot;Jake&quot;, &quot;Rick&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">values</span>()) <span class="comment">// [&#x27;colin1225@email.com&#x27;, &#x27;jake0305@email.com&#x27;, &#x27;rick1010@email.com&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">get</span>(<span class="string">&#x27;Rick&#x27;</span>)) <span class="comment">// &#x27;rick1010@email.com&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="雜湊表-HashMap"><a href="#雜湊表-HashMap" class="headerlink" title="雜湊表 HashMap"></a>雜湊表 HashMap</h2><p>HashTable 也稱作 HashMap，是 Dictionary 類別的一種實作方式。<br>使用雜湊演算法是為了更快更精準的在資料中找到一個值。以往我們要在資料結構中獲得一個值，要經過遍歷整個資料集。<br>雜湊讓我們利用函數就能得到資料的具體位置，因而達到快速檢索的效果。</p><p><img src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*0xeEq-iJDrVAU0zG.png" alt="HashMap"></p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li>雜湊函數: 給定一個鍵值，返回值在表中的地址。</li><li>put(key, value): 向雜湊表增加一個新資料。</li><li>remove(key): 根據鍵值從表中移除值。</li><li>get(key): 根據鍵值檢索特定值，返回。</li></ul><h3 id="實作-1"><a href="#實作-1" class="headerlink" title="實作"></a>實作</h3><h4 id="雜湊函數"><a href="#雜湊函數" class="headerlink" title="雜湊函數"></a>雜湊函數</h4><p>順序第一位為雜湊函式，是 HashTable 中一個私有的函數。<br>這邊使用一個最常見的 – 「雙輸」(lose lose)，將每一個鍵值中的每個字母的 ASCII 值相加。<br>在函式的最後常會使用 hash 值和任意數做除法的餘數(mod)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loseloseHashCode = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;key.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    hash += key.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(position + <span class="string">&#x27;-&#x27;</span> + key);</span><br><span class="line">  table[position] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>使用雜湊函式求出 key 值所對應位置，並回傳 position。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> table[<span class="title function_">loseloseHashCode</span>(key)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">  table[<span class="title function_">loseloseHashCode</span>(key)] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-HashTable-類別"><a href="#使用-HashTable-類別" class="headerlink" title="使用 HashTable 類別"></a>使用 HashTable 類別</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> <span class="title class_">HashTable</span>()</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Colin&#x27;</span>, <span class="string">&#x27;colin1225@email.com&#x27;</span>)</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;jake0305@email.com&#x27;</span>)</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Rick&#x27;</span>, <span class="string">&#x27;rick1010@email.com&#x27;</span>)</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">  20 - Colin</span></span><br><span class="line"><span class="comment">  9 - Jake</span></span><br><span class="line"><span class="comment">  23 - Rick</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用 get()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Colin&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Eileen&#x27;</span>));</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">  colin1225@eamil.com</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由於 Colin 是存在表中的鍵，所以會返回它的值。但 Eileen 並不在裡面，當我們試著取出值時，回傳將為 undefined（不存在）。<br>如果對 Colin 執行 remove()，那理所當然也會 return undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash.<span class="title function_">remove</span>(<span class="string">&#x27;Colin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Colin&#x27;</span>));</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="雜湊集合"><a href="#雜湊集合" class="headerlink" title="雜湊集合"></a>雜湊集合</h2><p>接著，我們來說明一下『雜湊集合』這個專有名詞。<br>在某些程式語言中，你會發現有這樣的一個實作。我們可以從名稱中了解到這是由集合所構成，但是新增、插入、刪除，是使用雜湊函數。<br>與剛才我們的實作不同之處，不添加「鍵值對」，只插入值。例如存放水果種類，但不賦予它們定義。</p><h2 id="雜湊表的衝突"><a href="#雜湊表的衝突" class="headerlink" title="雜湊表的衝突"></a>雜湊表的衝突</h2><p>有時候，會遇到有相同雜湊值的情況。不同的值在表中相同的位置，稱之為衝突。<br>在正常程式執行的情況下，最後添加的值將會佔據該位置，也就是會覆蓋掉。<br>當然，我們的目的就是要將所有的資料存放進來，這樣的話不就達不到初衷了嗎？</p><h3 id="面對衝突的處理"><a href="#面對衝突的處理" class="headerlink" title="面對衝突的處理"></a>面對衝突的處理</h3><p>在遇到衝突時，有兩個方法：</p><ol><li>Separate Chaining</li><li>Linear Probing</li></ol><h4 id="Separate-Chaining"><a href="#Separate-Chaining" class="headerlink" title="Separate Chaining"></a>Separate Chaining</h4><ul><li>一個(Key)位置允許放入多個值</li><li>每一個位置(Point)都指向一個 Linked List，以存放多個值</li><li>如果一個位置沒有放置任一值，Pointer 會被視為 null</li></ul><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cUZn32yJu7Z-fnDhf1ICMJkZH-tUU_dYd-pxmJ1Wk5tVqLa6cKsJ_xm9zbop5Btzof6I0da_7Z0R9m0Fr-cveDGT6HI360YuNKxQ936-vpEUz1DJefDp8L7vlchhTyS3fAD3Lq5yb8zB4hwOVLSZGt=s480-no?authuser=0" alt="此圖片源自網路"></p><h4 id="Linear-Probing"><a href="#Linear-Probing" class="headerlink" title="Linear Probing"></a>Linear Probing</h4><ul><li>如果該 key 對應的位置已經佔用（衝突），則會存入下一個 point(index+1)。</li><li>can provide high performance because of its good locality of reference</li><li>需要注意的地方就是陣列的空間有機會被使用完。</li></ul><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/2560px-HASHTB12.svg.png" alt="來自wiki"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JavaScript 中的字典和雜湊表是非常有用的資料結構，可以用來快速查找鍵值對應的值。在 JavaScript 中，字典通常是用物件來實現，而雜湊表則可以使用 Map 來實現。這些資料結構非常常見，因此學習如何使用它們是很重要的。&lt;/p&gt;
&lt;p&gt;順道提一下，集合(Set) [值：值]所關注的是值的本體，而字典(Dictionary)、雜湊表(HashMap) [鍵：值]關注的是兩者的 Mapping 關聯，這樣就可以簡單區分開來了。&lt;/p&gt;
&lt;p&gt;在本篇文章中，我們將介紹如何在 JavaScript 中使用字典和雜湊表。我們將會討論它們的特性、如何使用它們來解決問題，以及它們的複雜度和效能。如果你對 JavaScript 的資料結構和算法感到興趣，這篇文章將會對你有所幫助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 LeetCode 技巧 』Prefix Sum 前綴和</title>
    <link href="https://colinchiu87.github.io/posts/Leetcode-prefixSum/"/>
    <id>https://colinchiu87.github.io/posts/Leetcode-prefixSum/</id>
    <published>2023-04-09T07:25:53.000Z</published>
    <updated>2023-06-25T10:58:55.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近開始學習資料結構，搭配著 LeetCode 進行練習，發現有很多解題的觀念都可以通用！<br>這次就來説說這次解到的題目，有錯誤的地方還請多多指教 &gt;_&lt;<br>以下為題目連結：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVtb3ZlLXplcm8tc3VtLWNvbnNlY3V0aXZlLW5vZGVzLWZyb20tbGlua2VkLWxpc3Qv">1171. Remove Zero Sum Consecutive Nodes from Linked List<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h2 id="Prefix-Sum-前綴和"><a href="#Prefix-Sum-前綴和" class="headerlink" title="Prefix Sum 前綴和"></a>Prefix Sum 前綴和</h2><p>什麼是前綴和呢？簡單來說，就是將前面的數相加得到的一個新的和陣列。<br>而得到的新陣列可以讓我們做一些事，求區間和（subarray）就是基礎應用之一。</p><p>當題目是整數列而且出現需要”子數列”或”連續的子數列”時，就能利用這著概念去解題，效果可說是相當不錯。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 取得前綴和，累加 array[0:i-1] 得到 prefixSumArray[i]</span></span><br><span class="line"><span class="keyword">let</span> prefixSumArray = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>];</span><br></pre></td></tr></table></figure><p>在實作上，我們就可以直接使用這個數列進行累加，就不用再去遍歷一次 array。</p><h2 id="解題絲路"><a href="#解題絲路" class="headerlink" title="解題絲路"></a>解題絲路</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>先來看題目~<br>在給定的鏈結裡面，重複扣除總和為 0 的<strong>連續數列</strong>，直到沒有這類的數列為止。<br>最後返回剩餘的鏈結。</p><p>寫之前再到最下面看一下”條件(Constraints)”，這很重要呦！</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>看到”連續數列”，我們就可以試著利用 Prefix Sum。<br>另外補充，一般來說，前綴和會和 Map 一起做使用。</p><ol><li><p>建構一個 MAP 來儲存具有同累加值的最後節點的累積和。<br>因為最後一個節點的下一個數值是我們要建造和連結輸出的地方。</p></li><li><p>將 MAP 給實作出來</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeZeroSumSublists = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 head == false，return head</span></span><br><span class="line">  <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 概念 prefix sum map</span></span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">  newNode.<span class="property">next</span> = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> current = newNode,</span><br><span class="line">    prefixSumMap = <span class="keyword">new</span> <span class="title class_">Map</span>(),</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    sum += current.<span class="property">val</span>;</span><br><span class="line">    prefixSumMap.<span class="title function_">set</span>(sum, current);</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  current = newNode;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    sum += current.<span class="property">val</span>;</span><br><span class="line">    current.<span class="property">next</span> = prefixSumMap.<span class="title function_">get</span>(sum).<span class="property">next</span>;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newNode.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="類似題型"><a href="#類似題型" class="headerlink" title="類似題型"></a>類似題型</h2><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3ViYXJyYXktc3VtLWVxdWFscy1rLw==">560. Subarray Sum Equals K<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1hdmVyYWdlLXN1YmFycmF5LWkv">643. Maximum Average Subarray I<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近開始學習資料結構，搭配著 LeetCode 進行練習，發現有很多解題的觀念都可以通用！&lt;br&gt;這次就來説說這次解到的題目，有錯誤的地方還請多多指教 &amp;gt;_&amp;lt;&lt;br&gt;以下為題目連結：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmVtb3ZlLXplcm8tc3VtLWNvbnNlY3V0aXZlLW5vZGVzLWZyb20tbGlua2VkLWxpc3Qv&quot;&gt;1171. Remove Zero Sum Consecutive Nodes from Linked List&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="https://colinchiu87.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Python 分割字串的幾種方式</title>
    <link href="https://colinchiu87.github.io/posts/Python-splitString/"/>
    <id>https://colinchiu87.github.io/posts/Python-splitString/</id>
    <published>2023-02-06T11:00:09.000Z</published>
    <updated>2023-03-21T12:07:32.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做資料處理時，是不是很常遇到要做字串分割的時候呢？<br>這幾天本人剛好有遇到要擷取字串，就想研究一下，到底有哪些方法能滿足我的需求！</p><span id="more"></span><h2 id="擷取字串"><a href="#擷取字串" class="headerlink" title="擷取字串"></a>擷取字串</h2><h3 id="Slicing-分割"><a href="#Slicing-分割" class="headerlink" title="Slicing 分割"></a>Slicing 分割</h3><p>這個方法就像陣列以索引取值一樣，短到字元、長到字段。</p><ul><li>字元<br>語法：字串[索引]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_string = <span class="string">&quot;apple&quot;</span></span><br><span class="line"><span class="built_in">print</span>(some_string[<span class="number">1</span>]) <span class="comment"># &quot;p&quot;</span></span><br></pre></td></tr></table></figure><ul><li>字串中的子字串(substring)<br>語法：字串[起始:結束:間隔]<br>參數介紹：索引值是由計算是由 0 開始，所以起始值要 +1 取值，例如起始值 2 代表要由第 3 個字元開始；結束值要取值時自己不能算。例如結束等於 5，所以取到第 5 個值；間隔值不是必填，預設是 1。起始值不填就代表由最前方開始，結束值如果不填就代表算到底。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&quot;peach&quot;</span></span><br><span class="line"><span class="built_in">print</span>(fruit[<span class="number">2</span>:<span class="number">4</span>]) <span class="comment"># &quot;ac&quot;</span></span><br><span class="line"><span class="built_in">print</span>(fruit[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># &quot;pah&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fruit[::-<span class="number">1</span>]) <span class="comment"># 反轉字串 &quot;hcaep&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Split-分割字串為陣列"><a href="#Split-分割字串為陣列" class="headerlink" title="Split 分割字串為陣列"></a>Split 分割字串為陣列</h3><p>你有時候會遇到資料是利用 “,” “、” “空格” “-“ 等符號來區分每一筆資料。</p><p>這時候就需要把這些字串做處理，讓它變成陣列方便我們使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fruit = <span class="string">&quot;apple,banana,peach&quot;</span></span><br><span class="line">data_arr = fruit.split(<span class="string">&quot;,&quot;</span>)  <span class="comment"># - 使用逗號分割</span></span><br><span class="line"><span class="built_in">print</span>(fruit)</span><br><span class="line"><span class="built_in">print</span>(data_arr)  <span class="comment"># - [apple, banana, peach]</span></span><br><span class="line"><span class="built_in">print</span>(data_arr[<span class="number">0</span>])  <span class="comment"># - apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># - 適用任何符號！</span></span><br><span class="line"><span class="comment"># - 多多研究要處理的資料有什麼特性或規律，在處理上能有較好的效率。</span></span><br></pre></td></tr></table></figure><h3 id="Regexes-正規表達式"><a href="#Regexes-正規表達式" class="headerlink" title="Regexes 正規表達式"></a>Regexes 正規表達式</h3><p>又稱作正則表達式。Python 支援的介面存放在 re 的模組裡，所以要使用記得要引用(import re)</p><p>正規表達式是很適合用來匹配字串極好用的工具，有獨立的語法，並能透過特定的語句規則（Pattern），達到搜尋、匹配、替代等等的需求。</p><ul><li><p>reg.split()<br>我們可以編譯一個正則表達式，用它來分割字串，和 python.split 一樣，返回一個包含子字串的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">fruit = <span class="string">&quot;apple banana peach&quot;</span></span><br><span class="line">regex = re.complie(<span class="string">&#x27;\s+&#x27;</span>)  <span class="comment"># - \s 是一個特殊字元，包含所有的空白字元（空白、TAB、換行符號），而＋則代表一個或多個空格。</span></span><br><span class="line">result = regex.split(fruit)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>推薦一個網站，<span class="exturl" data-url="aHR0cHM6Ly9yZWdleDEwMS5jb20v">https://regex101.com/<i class="fa fa-external-link-alt"></i></span>能即時將你輸入的字串比對你的正規表達式語法。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做資料處理時，是不是很常遇到要做字串分割的時候呢？&lt;br&gt;這幾天本人剛好有遇到要擷取字串，就想研究一下，到底有哪些方法能滿足我的需求！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://colinchiu87.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』集合 Set</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-set/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-set/</id>
    <published>2022-11-21T08:07:35.000Z</published>
    <updated>2023-04-09T07:31:51.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這週要帶各位認識的資料結構是「集合 Set」。在深入探索它之前先讓我們看一下他的數學概念，在裡頭集合是一組不同的物件（的集合）。</p><p>比如說，一個由大於或等於零的整數組成的自然數集合：Ｎ &#x3D; {0, 1, 2, 3, 4, 5, …}。集合中的物件列表用{}包圍起來。</p><p>另一個概念為「空集」，不包含任何元素的集合。比如說： 20, 23 這兩個數字之間的質數集合，由於這兩數之間沒有質數（除了 1 和本身，沒有其他正因數的大於一的自然數），這個集合就是空集合。用 { } 表示。個人覺得本章節在資料結構中蠻重要的，特別是對於後端在資料庫存取時常用到這一個概念。</p><span id="more"></span><h2 id="什麼是集合？"><a href="#什麼是集合？" class="headerlink" title="什麼是集合？"></a>什麼是集合？</h2><p>集合是由一組無序且唯一的項目組成的。這個資料結構使用了與有限集合相同的概念，但應用在電腦科學的資料結構中。你也可以把集合想成一個既沒有元素，也沒有順序的陣列。在數學中，集合也有聯集、焦急、差集，在接下來也會一一介紹操作。</p><h2 id="建立一個集合"><a href="#建立一個集合" class="headerlink" title="建立一個集合"></a>建立一個集合</h2><p>在 ES6 中，已經有 Set 的類別，<del>終於遇到原生的資料結構了</del>QAQ<br>不過以下我們還是自己寫一個會比較印象深刻！</p><p>這是我們的 Set 類別骨架：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Set</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡有一個細節，我們使用的不是陣列而是物件，原因是 Java Script 的物件是不允許一個鍵指向兩個不同屬性，保證了元素都是唯一的。</p><p>開始宣告一些集合可用的方法：</p><ul><li>add(value)：向集合添加一個新的項目。</li><li>remove(value)：從一個集合移除一個值。</li><li>has(value)：如果值在集合中，返回 true，反之 false。</li><li>clear()：移除集合中所有項目。</li><li>size()：返回集合所包含元素的數量。與陣列 length 相同。</li><li>values()：返回一個包含集合中所有值的陣列。</li></ul><h3 id="has-value"><a href="#has-value" class="headerlink" title="has(value)"></a>has(value)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">has</span>(value) = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">in</span> items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然我們用物件來存放集合的值，就可以使用 JS 的 in 運算子來驗證是否是物件的屬性。</p><p>&#x3D;&#x3D;補充一個方法 obj.hasOwnProperty(prop)，它會返回一個布林值，指示物件自身屬性中（非繼承屬性）是否具有指定的屬性。&#x3D;&#x3D;</p><h3 id="add-value"><a href="#add-value" class="headerlink" title="add(value)"></a>add(value)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">    items[value] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新增項目時，先檢查它是否存在於集合中。</p><p>&#x3D;&#x3D;添加一個值的時候，把它同時當作鍵和值儲存，因為這樣有利於尋找這個值&#x3D;&#x3D;</p><h3 id="remove-value-clear"><a href="#remove-value-clear" class="headerlink" title="remove(value) &amp; clear()"></a>remove(value) &amp; clear()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">    <span class="keyword">delete</span> items[value];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法中，我們會驗證給定的 value 是否存在於集合中。如果存在，就從集合中移除 value，返回 true，表示值被移除；否則返回 false。</p><p>既然用物件來存放集合的 items 物件，就可以使用 delete 運算子從 items 物件中移除屬性。</p><p>使用 Set 類別的範例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>出於好奇，如果執行以上程式碼之後，在主控台（ console.log ）輸出 items 變數，Google Chrome 就會輸出如下內容：<br>  Object{ 1: 1, 2: 2 }<br>可以看到，這是一個有兩個屬性的物件。屬性名就是添加到集合的值同時它也是屬性值</p></blockquote><p>如果想移除集合中的所有值，可以用 clear 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  items = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要重設 items 物件，需要做的只是把一個空物件重新賦值給它。</p><h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><p>這裡會有三種實作方法。</p><p>第一種是使用一個 length 變數，每當使用 add 或 remove 方法時控制它。</p><p>第二種方法，使用 JavaScript 內建的 Object 類別的一個內建函數（ ECMAScript 5 以上版本 ）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三種方法是手動提取 items 物件的每一個屬性，紀錄屬性的個數並返回這個數字。這可以運行在每個瀏覽器，和之前的程式碼是等價的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">sizeLegacy</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> items)&#123;</span><br><span class="line">    <span class="keyword">if</span>(items.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">      ++count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍歷 items 物件的所有屬性，檢查它們是否是物件本身的屬性。如果是，就遞增 count 值，最後在方法結束再返回這數字。</p><blockquote><p>不能簡單地使用 for-in 語句遍歷 items 物件的屬性，遞增 count 變數的值。還需要使用 has 方法，因為物件的原型包含了額外的屬性。</p></blockquote><h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-Set-類別"><a href="#使用-Set-類別" class="headerlink" title="使用 Set 類別"></a>使用 Set 類別</h3><p>資料結構已經完成囉，看看怎麼使用它吧！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">// [&quot;1&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">size</span>()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">set.<span class="title function_">remove</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>()); <span class="comment">// [&quot;2&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>對集合可以進行的操作如下：</p><ul><li>聯集：給定的兩集合，返回一個包含兩個集合中所有元素的新集合。</li><li>交集：給定的兩集合，返回一個包含兩個集合中共有元素的新集合。</li><li>差集：給定的兩集合，返回一個包含所有存在於第一個集合且不存在於第二個集合的元素的新集合。</li><li>子集：驗證一個給定集合是否是另一集合的子集。</li></ul><h3 id="聯集"><a href="#聯集" class="headerlink" title="聯集"></a>聯集</h3><p>集合 A 和 B 的聯集，表示為 $ A\bigcup B $ ，定義如下：</p><p>$$ A\bigcup B &#x3D; { x | x \in A \bigvee x \in B } $$</p><p>意思是 x （元素）存在於 A 中，或 x 存在於 B 中。</p><img src="/posts/DataStructure-set/set_union.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">union</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> unionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  values = otherSet.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>意思是 x （元素）存在於 A 中，且 x 存在於 B 中。</p><img src="/posts/DataStructure-set/Set_intersection.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">intersection</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">      intersectionSet.<span class="title function_">add</span>(values.[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>意思是 x （元素）存在於 A 中，且 x 不存在於 B 中。</p><img src="/posts/DataStructure-set/Set_difference.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">difference</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> differenceSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">      differenceSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>意思是集合 A 中的每一個 x （元素），也需要存在於 B 中。</p><img src="/posts/DataStructure-set/subset.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">subset</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>() &gt; otherSet.<span class="title function_">size</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這章學習了如何從頭實作與 ES6 中定義的類似的 Set 類別。我們還介紹了在其他程式語言的集合結構的實作中不常見的一些方法，例如：連擊、交集、差集..等。相較於前幾個主題，我們完成了較完善的實例！給自己一個掌聲 👏🏻</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這週要帶各位認識的資料結構是「集合 Set」。在深入探索它之前先讓我們看一下他的數學概念，在裡頭集合是一組不同的物件（的集合）。&lt;/p&gt;
&lt;p&gt;比如說，一個由大於或等於零的整數組成的自然數集合：Ｎ &amp;#x3D; {0, 1, 2, 3, 4, 5, …}。集合中的物件列表用{}包圍起來。&lt;/p&gt;
&lt;p&gt;另一個概念為「空集」，不包含任何元素的集合。比如說： 20, 23 這兩個數字之間的質數集合，由於這兩數之間沒有質數（除了 1 和本身，沒有其他正因數的大於一的自然數），這個集合就是空集合。用 { } 表示。個人覺得本章節在資料結構中蠻重要的，特別是對於後端在資料庫存取時常用到這一個概念。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』鏈結串列 Linked-List</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-linkedList/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-linkedList/</id>
    <published>2022-11-21T07:36:21.000Z</published>
    <updated>2023-04-09T07:30:54.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這週要帶各位認識的資料結構是「 鏈結串列 Linked-List 」，一開始所學的陣列（串列）是一種非常簡易能讓我們存放資料序列的資料結構，而鏈結串列則是一種動態的，我們進行新增或刪減元素，就會依照需求進行擴充。陣列應該是大家最常用的資料結構，每種語言都支持它，但是卻有一個隱憂：在大多數的語言中，<strong>陣列的大小是固定的</strong>，從起點或中間插入、移除元素是非常耗成本的。</p><span id="more"></span><h2 id="鏈結串列-Linked-List"><a href="#鏈結串列-Linked-List" class="headerlink" title="鏈結串列(Linked-List)"></a>鏈結串列(Linked-List)</h2><p>鏈結串列存放著有序的資料，但與陣列不同的是，其中的元素在記憶體中並不是連續放置的，每個元素是由一個節點和一個指向下一個元素的鏈結組成。</p><p><a href="https://miro.medium.com/max/970/1*ZsQoOXgnSpaEDlUEVOoKgA.png"><img src="https://miro.medium.com/max/970/1*ZsQoOXgnSpaEDlUEVOoKgA.png" alt="鏈結串列"></a></p><h3 id="優劣之處"><a href="#優劣之處" class="headerlink" title="優劣之處"></a>優劣之處</h3><p>優點顯而易見，在我們新增元素或刪除時並不需要去移動其他的元素，只需要注意將鏈結重新調整就好。<br>上帝開了一扇窗給你，就會關你一扇門。<br>你還記得陣列可以隨意存取任何位置的任何元素嗎？而鏈結串列只能從起點也就是 head 開始迭代下去。如果你在考慮要使用陣列還是鏈結串列時，不妨可以針對你的需求來做出較佳的選擇。</p><h3 id="現實中的實例"><a href="#現實中的實例" class="headerlink" title="現實中的實例"></a>現實中的實例</h3><ul><li>尋寶遊戲<br>依照線索一道一道往下解謎。<br><a href="https://www.suloves.com/ckfinder/userfiles/images/depositphotos_10772916-stock-photo-treasure-map.jpg"><img src="https://www.suloves.com/ckfinder/userfiles/images/depositphotos_10772916-stock-photo-treasure-map.jpg" alt="尋寶"></a></li><li>火車<br>由一節一節的車廂連結而成，很容易將其分開。<br><a href="https://taiwan.sharelife.tw/tw-news-img/50859/e277220720385717.jpg"><img src="https://taiwan.sharelife.tw/tw-news-img/50859/e277220720385717.jpg" alt="火車"></a></li></ul><h3 id="建立鏈結串列"><a href="#建立鏈結串列" class="headerlink" title="建立鏈結串列"></a>建立鏈結串列</h3><p>瞭解 Linked-List 後，我們就要用程式來實作啦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向串列尾部添加一個新元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">append</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>)&#123;</span><br><span class="line">      head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 串列迴圈，直到找到最後一個</span></span><br><span class="line">      <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到最後一項，將其 next 指向 node ，建立鏈結</span></span><br><span class="line">      current.<span class="property">next</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length++; <span class="comment">// 更新串列長度</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向串列的特定位置插入一個新元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">position, element</span>)&#123;</span><br><span class="line">    <span class="comment">// 檢查越界值</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">          previous,</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">        node.<span class="property">next</span> = current;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          previous = current;</span><br><span class="line">          current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="property">next</span> = current;</span><br><span class="line">        previous = node;</span><br><span class="line">      &#125;</span><br><span class="line">      length++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 從特定位置移除一項</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">    <span class="comment">// 檢查越界值</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length)&#123;</span><br><span class="line">      <span class="keyword">let</span> current = head,</span><br><span class="line">          previous,</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 移除第一項</span></span><br><span class="line">      <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">        head = current.<span class="property">next</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          previous = current;</span><br><span class="line">          current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 previous 與 current 的下一項鏈結起來：跳過 current ，進而移除它 previous.next = current.next;</span></span><br><span class="line">      &#125;</span><br><span class="line">      length--;</span><br><span class="line">      <span class="keyword">return</span> current.<span class="property">element</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 從串列中移除一項</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回元素在串列中的索引。如果串列中沒有該元素則返回 -1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head,</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">      <span class="keyword">if</span>(element === current.<span class="property">element</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      index++;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鏈結串列中不含任何元素，返回 true。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回鏈結串列包含的元素個數。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由於使用了 Node 類別，就需要覆寫繼承自 Js 物件預設的方法，讓其只輸出元素的值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head,</span><br><span class="line">        string = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(current)&#123;</span><br><span class="line">      string += current.<span class="property">element</span>;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linked-List 還需要一個 Node 類別來輔助，表示要加入串列的項目。它包含一個值 (element) ，和 指向串列中下一個節點的指位器 next 屬性。另一個重點是，我們還要一個用來存放第一個節點的引用(head)。</p><h3 id="方法詳述"><a href="#方法詳述" class="headerlink" title="方法詳述"></a>方法詳述</h3><p>相關的程式碼都在上方，這邊就不再多打一次了，我們直接說明邏輯的部份！</p><h4 id="添加：在鏈結串列尾部追加元素"><a href="#添加：在鏈結串列尾部追加元素" class="headerlink" title="添加：在鏈結串列尾部追加元素"></a>添加：在鏈結串列尾部追加元素</h4><p>append(element)，這邊有兩種情況，一是串列為空；二是不為空。</p><ul><li>向空串列添加一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist4.jpg" class=""><p>如果 head 的值為 null，就意味著在向串列添加第一個元素，所以要做的是將 head 指向 node 元素。而 node.next &#x3D;&#x3D; null。</p><ul><li>向一個不為空的串列尾部添加元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist5.jpg" class=""><p>首先，要先找到最後一個元素。<br>⚠️ 要注意的是我們只知道第一個元素，因此需要迴圈存取串列，直到找出最後一個。<br>為此我們要一個變數是指向串列中 current 項目，當 current.next 為 null 時，就知道我們到達串列尾端了。接下來要做的就是讓當前（也就是最後一個）元素的 next 指位器指向想要添加的串列節點上。</p><h4 id="移除：從鏈結串列中移除元素"><a href="#移除：從鏈結串列中移除元素" class="headerlink" title="移除：從鏈結串列中移除元素"></a>移除：從鏈結串列中移除元素</h4><p>removeAt(position)，該方法要得到移除元素的位置，就需要先驗證這個位置是有效的。從 0 到串列長度都是有效位置。如果不是有效，就 return null（意即沒從串列移除元素）。</p><p>兩種情況：一是移除第一個元素；二是移除第一個以外的任意元素。</p><ul><li>從串列中移除第一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist6.jpg" class=""><p>要做的是讓 head 指向串列第二個元素。我們將用 current 變數建立一個對串列中第一個元素引用。將 head 賦為 current.next，就完成了。</p><ul><li>從串列中移除中間元素</li></ul><p>需要依靠一個細節迭代串列，直到到達目標位置（使用一個用於內部控制和遞增的 index 變數）：current 變數總是為對串列迴圈的當前元素的引用；他被命名為 previous。</p><p>因此，要從串列中移除當前元素，要做的就是將 previous.next 和 current.next 鏈結起來。這樣當前元素就會被丟棄在電腦記憶體中，等著被垃圾回收桶清除。</p><ul><li>從串列中移除最後一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist7.jpg" class=""><p>當我們跳出迴圈，current 是對串列中最後一個元素（要移除的項目），current.next 為 null（因為他是最後一元素）。由於還保留著 previous 元素引用，要做的就是把 previous.next 的值改成 current.next。</p><h4 id="插入：在串列任意位置插入一個元素"><a href="#插入：在串列任意位置插入一個元素" class="headerlink" title="插入：在串列任意位置插入一個元素"></a>插入：在串列任意位置插入一個元素</h4><p>insert(position, element)，由於要處理到位置，就必須在一開始檢查臨界值，如果越界了就 return false，表示沒有完成添加。</p><ul><li>在串列起點添加一個元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist.jpg" class=""><p>current 是對串列第一個數的引用。我們要做的是把 node.next 的值設成 current。現在 head 和 node.next 都指向 current。接著就是將 head 改成 node，這樣串列就多一個元素了。</p><ul><li>在串列尾部添加元素</li></ul><p>首先，需要用迴圈存取串列，找到目標的 position。當跳出迴圈時，就是 current 到達我們想要插入新元素位置的後一個元素，而 previuos 是對想要插入新元素的位置之前一個元素的引用。在這情況下，我們要在 current, previous 之間添加，因此，首先要把新項目(node)和當前項目鏈結起來，然後再改變 previous 和 current 之間的鏈結，我們還要將 previous.next 指向 node。</p><img src="/posts/DataStructure-linkedList/linkedlist2.jpg" class=""><p>如果我們試圖向最後一位添加新項目，previous 將會是串列最後一個，而 current 將會是 null。在這情況，node.next 將指向 current，而 previous.next 指向 node。</p><ul><li>在串列中間添加元素</li></ul><img src="/posts/DataStructure-linkedList/linkedlist3.jpg" class=""><p>試著將 node 插入到 prev, curr 之間。首先，我們要把 node.next 指向 curr。然後把 prev.next 的值設為 node，這樣就完成囉。</p><h2 id="雙向鏈結串列-Double-Linked-List"><a href="#雙向鏈結串列-Double-Linked-List" class="headerlink" title="雙向鏈結串列 (Double Linked List)"></a>雙向鏈結串列 (Double Linked List)</h2><img src="/posts/DataStructure-linkedList/linkedlist8.png" class=""><p>相較原型，雙向鏈結的串列 node 多了一個 prev，而 list 也多了一個 tail。<br>我們可想而知，多了向前的鏈結，讓我們可以解開單向迭代的枷鎖，不只可以從頭到尾，也可以反過來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DoublyLinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>; <span class="comment">// 雙向串列才有</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">// 雙向串列才有</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在任意位置添加新元素"><a href="#在任意位置添加新元素" class="headerlink" title="在任意位置添加新元素"></a>在任意位置添加新元素</h3><p>和單向的鏈結串列的區別在於，雙向鏈結串列需要同時控制 next, prev 兩個指位器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">element, position</span>) &#123;</span><br><span class="line">  <span class="comment">// 檢查是否越界</span></span><br><span class="line">  <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current = head,</span><br><span class="line">        previous,</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 項目添加在第一個位置</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 空串列</span></span><br><span class="line">      <span class="keyword">if</span> (!head) &#123; <span class="comment">// new</span></span><br><span class="line">        head = node;</span><br><span class="line">        tail = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.<span class="property">next</span> = current;</span><br><span class="line">        current.<span class="property">prev</span> = node; <span class="comment">// new</span></span><br><span class="line">        head = node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length)&#123; <span class="comment">// 添加在最後一項 // new</span></span><br><span class="line">      current = tail;</span><br><span class="line">      current.<span class="property">next</span> = node;</span><br><span class="line">      node.<span class="property">prev</span> = current;</span><br><span class="line">      tail = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node.<span class="property">next</span> = current;</span><br><span class="line">      previous.<span class="property">next</span> = node;</span><br><span class="line"></span><br><span class="line">      current.<span class="property">prev</span> = node; <span class="comment">// new</span></span><br><span class="line">      node.<span class="property">prev</span> = previous; <span class="comment">// new</span></span><br><span class="line">    &#125;</span><br><span class="line">    length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="環狀鏈結串列"><a href="#環狀鏈結串列" class="headerlink" title="環狀鏈結串列"></a>環狀鏈結串列</h2><p>環狀鏈結串列可以單向也可以雙向。和鏈結串列不同的是，最後尾端指向的不是 null，而是第一個元素 (head)。</p><img src="/posts/DataStructure-linkedList/linkedlist9.jpg" class=""><h2 id="結"><a href="#結" class="headerlink" title="結"></a>結</h2><p>我們今天學到了鏈結串列這個結構，和陣列相比最重要的優點就是無需移動鏈結串列中的元素，就能輕輕鬆鬆添加或移除元素。<br>當你需要添加和移除很多元素時，最好的選擇非鏈結串列(Linked-List)莫屬！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這週要帶各位認識的資料結構是「 鏈結串列 Linked-List 」，一開始所學的陣列（串列）是一種非常簡易能讓我們存放資料序列的資料結構，而鏈結串列則是一種動態的，我們進行新增或刪減元素，就會依照需求進行擴充。陣列應該是大家最常用的資料結構，每種語言都支持它，但是卻有一個隱憂：在大多數的語言中，&lt;strong&gt;陣列的大小是固定的&lt;/strong&gt;，從起點或中間插入、移除元素是非常耗成本的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』佇列 Queue</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-queue/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-queue/</id>
    <published>2022-10-25T02:17:23.000Z</published>
    <updated>2023-04-15T06:37:09.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第三週我們歡迎「 Queue 佇列 」，上週我們學會了 stack ，這兩個東西非常相似，但是原則不同！<br>佇列在尾端新增元素，在頂部移除，在現實中就像是我們在排隊一樣，排在前面的人會優先被服務到，因此也有一個別稱叫做「 隊列 」。</p><img src="/posts/DataStructure-queue/queue.webp" class=""><span id="more"></span><h2 id="佇列什麼來頭？"><a href="#佇列什麼來頭？" class="headerlink" title="佇列什麼來頭？"></a>佇列什麼來頭？</h2><p>佇列是遵守著 FIFO (First In First Out, 先進先出) 原則的有序項目。</p><ul><li>一群相同性質元素的組合</li><li>具有 FIFO 特性</li><li>加入元素發生在尾端</li><li>刪除元素發生在頂端</li></ul><p>在 Computer Science 中，最常看到的例子就是列印佇列。假如我們要列印三份文件，會開啟檔案並按下列印的按鈕，每個文件都會被發送至列印佇列，第一個發送到的文件會首先被列印出來，直到所有文件都列印完成。</p><h2 id="建立佇列"><a href="#建立佇列" class="headerlink" title="建立佇列"></a>建立佇列</h2><h3 id="宣告類別"><a href="#宣告類別" class="headerlink" title="宣告類別"></a>宣告類別</h3><p>首先來宣告一個類別來建立自己的佇列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Queue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 寫入屬性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們需要一個用於存放元素的結構，這邊可以使用陣列，就像上一篇 Stack 那樣做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = []</span><br></pre></td></tr></table></figure><h3 id="宣告方法"><a href="#宣告方法" class="headerlink" title="宣告方法"></a>宣告方法</h3><p>接下來讓我們開始宣告方法吧！以下是佇列可用的幾種方法：</p><ul><li>enqueue(element(s)): 向佇列尾端增加一個(或多個)新元素。</li><li>dequeue(): 刪除佇列第一個元素(即排在最前面的)，並返回該元素。</li><li>front(): 返回佇列第一個元素－－最先加入的。（與 Stack 的 peek 方法極為相似）</li><li>isEmpty(): 如果佇列中不包含任何元素，返回 true，反之返回 false。</li><li>size(): 返回佇列裡的元素個數，與陣列的 length 相同。</li></ul><p>第一個就是我們的‘新增’，記住佇列只能從未端添加！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">enqueue</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">  items.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實作佇列移除元素。由於只能遵循先進先出原則，最先加入的也是最先移除的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">dequeue</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="title function_">shift</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有 enqueue, dequeue 兩種方法可以新增及刪除元素，這樣確保了 Queue 類別先進先出的規則。</p><p>接著就是屬於比較輔助的方法。<br>如果想知道佇列最前面的元素是什麼，可以用 front 方法，將返回佇列 index 為 0 的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">front</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isEmpty 如果佇列為空，返回 true，反之 false。常用於驗證。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後我們可以讓 Queue 類別實作類似 Array 類別的 length 屬性的方法。size 方法也和 Stack 裡的一樣：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到這邊，我們完成了！</p><h3 id="完整-Queue-類別"><a href="#完整-Queue-類別" class="headerlink" title="完整 Queue 類別"></a>完整 Queue 類別</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Queue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">enqueue</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    items.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dequue</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">front</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)[</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="與-Stack-不同之處"><a href="#與-Stack-不同之處" class="headerlink" title="與 Stack 不同之處"></a>與 Stack 不同之處</h2><p>唯一的區別是 dequeue 方法和 front 方法，這是由於先進先出和後進先出原則的不同所造成的。</p><h2 id="使用-Queue-類別"><a href="#使用-Queue-類別" class="headerlink" title="使用 Queue 類別"></a>使用 Queue 類別</h2><p>第一步：實例化 Queue。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">isEmpty</span>()); <span class="comment">// 輸出 true</span></span><br></pre></td></tr></table></figure><p>新增一些元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;Mike&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以玩一玩其他的方法～</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="title function_">dequeue</span>();</span><br><span class="line">queue.<span class="title function_">size</span>(); <span class="comment">// 1</span></span><br><span class="line">queue.<span class="title function_">isEmpty</span>();  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="特殊佇列"><a href="#特殊佇列" class="headerlink" title="特殊佇列"></a>特殊佇列</h2><h3 id="優先佇列"><a href="#優先佇列" class="headerlink" title="優先佇列"></a>優先佇列</h3><p>佇列大量的應用在我們的生活中和電腦科學中，我們在之前的實作原型佇列中，也有其他的延伸。<br>其中一個就是「優先佇列」。元素的添加、移除是基於優先級別的。機場的登機順序就是一個現實的例子，頭等艙和商務艙的優先級要高於經濟艙的乘客。有些國家，老人和孕婦也擁有高於其他乘客的級別。</p><p>另一個例子是醫院的急診室，醫生會優先處理重症患者，而護士通常會先行分類並決定次序。</p><img src="/posts/DataStructure-queue/queue1.jpg" class=""><p><em>取自<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9tL2FydGljbGVzLzEwMjY2OTgw">https://ithelp.ithome.com.tw/m/articles/10266980<i class="fa fa-external-link-alt"></i></span></em></p><p>實作一個優先佇列，有兩個選項：</p><ul><li>一是設定優先級，然後在正確的位置增加元素。</li><li>二是用入列操作新增元素，然候依照優先級移除它們。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PriorityQueue</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">QueueElement</span>(<span class="params">element, priority</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">priority</span> = priority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">enqueue</span> = <span class="keyword">function</span>(<span class="params">element, priority</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> queueElement = <span class="title function_">newQueueElement</span>(element, priority);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">      items.<span class="title function_">push</span>(queueElement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> added = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;items.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(queueElement.<span class="property">priority</span> &lt; items[i].<span class="property">priority</span>)&#123;</span><br><span class="line">          items.<span class="title function_">splice</span>(i, <span class="number">0</span>, queueElement);</span><br><span class="line">          added = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!added)&#123;</span><br><span class="line">        items.<span class="title function_">push</span>(queueElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他方法和預設的 Queue 實作相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>預設的類別和優先級佇列類別實作上的區別是，要向 PriorityQueue 新增元素，需要建立一個特殊元素。這個元素包含了要添加到佇列的元素（它可以是任意類型）及其在佇列中的優先級。</p><p>如果佇列為空，可以直接加入。否則，就需要先比較該元素與其他元素的優先級。當找到一個比要添加元素還要大的 priority 項目時，就把新元素插入到它之前（根據這個邏輯，相同優先級通樣要遵循先進先出原則）。</p><p>補充一點，這裡實作的稱為最小優先佇列，因為優先級較小被放置在最前面（ 1 表示更高優先 ）。最大優先佇列則與之相反。</p><h3 id="環狀佇列"><a href="#環狀佇列" class="headerlink" title="環狀佇列"></a>環狀佇列</h3><p>另一個延伸就是「環狀佇列」。遊戲燙手山芋（ Hot Potato ）就是一個很好的例子。<br>遊戲中，玩家圍成一個圈，把物品盡快地遞給旁邊的人，某一時刻傳遞停止，而這時候物品在誰手上，誰就退出圓圈結束遊戲。重複這個過程，直到一位勝者出爐。</p><img src="/posts/DataStructure-queue/queue2.webp" class=""><p><em>取自<span class="exturl" data-url="aHR0cHM6Ly93d3cuMTIzcmYuY29tL3Bob3RvXzEwOTE4MTAwX3Bhc3Npbmctb24tdGhlLWhvdC1wb3RhdG8tYS1jb25jZXB0Lmh0bWw=">https://www.123rf.com/photo_10918100_passing-on-the-hot-potato-a-concept.html<i class="fa fa-external-link-alt"></i></span></em></p><p>實作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hotPotato</span>(<span class="params">nameList, num</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nameList.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> eliminated = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="title function_">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    eliminated = queue.<span class="title function_">dequeue</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(eliminated + <span class="string">&#x27;在遊戲中被淘汰。&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queue.<span class="title function_">dequeue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Colin&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Eileen&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> winner = <span class="title function_">hotPotato</span>(names, <span class="number">7</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;勝利者&#x27;</span> + winner);</span><br></pre></td></tr></table></figure><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>我們這次學習了佇列的資料結構，自己實作佇列的演算法，學習如何透過 enqueue, dequeue 方法增加和刪除元素。還有兩種著名的特殊佇列實作：優先佇列、環狀佇列。</p><p>接下來我們將學習鏈結串列，比陣列更加複雜的資料結構呦！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第三週我們歡迎「 Queue 佇列 」，上週我們學會了 stack ，這兩個東西非常相似，但是原則不同！&lt;br&gt;佇列在尾端新增元素，在頂部移除，在現實中就像是我們在排隊一樣，排在前面的人會優先被服務到，因此也有一個別稱叫做「 隊列 」。&lt;/p&gt;
&lt;img src=&quot;/posts/DataStructure-queue/queue.webp&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>『 資料結構 』堆疊 Stack</title>
    <link href="https://colinchiu87.github.io/posts/DataStructure-stack/"/>
    <id>https://colinchiu87.github.io/posts/DataStructure-stack/</id>
    <published>2022-10-14T08:39:51.000Z</published>
    <updated>2023-04-09T07:31:57.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>準備好歡迎我們第二週的主題“堆疊”了嗎！<br>在電腦科學的江湖上流傳著一句話：</p><blockquote><p>程式設計 ＝ 資料結構 ＋ 演算法</p></blockquote><p>在各大專院校裡，這幾門課都列為必修課之一，但是大多缺乏語言的基礎，反而在這裡頭迷失了，學完就好像睡了一覺，模模糊糊迷迷茫茫…，我就是這樣😂</p><p>本篇將使用 JavaScript 來學習堆疊(Stack)的資料結構。</p><span id="more"></span><h2 id="堆疊是什麼？"><a href="#堆疊是什麼？" class="headerlink" title="堆疊是什麼？"></a>堆疊是什麼？</h2><p>堆疊是一種按照<em>後進先出</em> (LIFO, Last In First Out)的有序結構，舉個例子：日常生活中的疊盤子。先疊的盤子會在最下面，後面開始會疊在上方，一層一層往上，當要拿盤子時一定是從最上面拿。</p><p><img src="https://i0.wp.com/studyalgorithms.com/wp-content/uploads/2020/12/stack-of-plates_0.png?ssl=1" alt="疊盤子"></p><h2 id="建立堆疊"><a href="#建立堆疊" class="headerlink" title="建立堆疊"></a>建立堆疊</h2><p>開始進入實作的階段，GOGO🤟🏻</p><h3 id="類別"><a href="#類別" class="headerlink" title="類別"></a>類別</h3><p>首先，建立一個類別為 Stack:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Stack</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//宣告內部屬性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="屬性"><a href="#屬性" class="headerlink" title="屬性"></a>屬性</h3><p>我們下面會用 Array 的方式進行，所以宣告起來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [];</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>新增 push(element)、刪除 pop()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">  items.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刪除元素：會返回被移除的元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="title function_">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最上方元素為何 peek(), top()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回最上方元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items[items.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>堆疊還有元素嗎 isEmpty()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆疊內部是否還有元素存在 true, false</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>元素共有幾個 size()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆疊內部有多少元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>清空堆疊 clear()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆疊清空</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> items = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Stack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    items.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items[items.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> items = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="動手做做看"><a href="#動手做做看" class="headerlink" title="動手做做看"></a>動手做做看</h2><p>快速測試可以打開 chrome 的 console 操作看看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="string">&#x27;plateA&#x27;</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="string">&#x27;plateB&#x27;</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="string">&#x27;plateC&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack); <span class="comment">// [&#x27;plateA&#x27;, &#x27;plateB&#x27;, &#x27;plateC&#x27;]</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">pop</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack); <span class="comment">// [&#x27;plateA&#x27;, &#x27;plateB&#x27;]</span></span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">size</span>() <span class="comment">// 2</span></span><br><span class="line">stack.<span class="title function_">peek</span>() <span class="comment">// &#x27;plantB&#x27;</span></span><br><span class="line">stack.<span class="title function_">clear</span>() <span class="comment">// []</span></span><br><span class="line">stack.<span class="title function_">isEmpty</span>() <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最後到 leetcode 驗收一下自己學習的成果吧！<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXF1ZXVlLXVzaW5nLXN0YWNrcy8=">232. Implement Queue using Stacks<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">20. Valid Parentheses<i class="fa fa-external-link-alt"></i></span></p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zdHVkeWFsZ29yaXRobXMuY29tL3RoZW9yeS9zdGFjay1kYXRhLXN0cnVjdHVyZS8=">What is a Stack?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxNTExOA==">前端工程師用 javaScript 學演算法<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNSVBMCU4NiVFNiVBMCU4OA==">堆疊- 維基百科，自由的百科全書 - Wikipedia<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;準備好歡迎我們第二週的主題“堆疊”了嗎！&lt;br&gt;在電腦科學的江湖上流傳著一句話：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;程式設計 ＝ 資料結構 ＋ 演算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在各大專院校裡，這幾門課都列為必修課之一，但是大多缺乏語言的基礎，反而在這裡頭迷失了，學完就好像睡了一覺，模模糊糊迷迷茫茫…，我就是這樣😂&lt;/p&gt;
&lt;p&gt;本篇將使用 JavaScript 來學習堆疊(Stack)的資料結構。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structure" scheme="https://colinchiu87.github.io/tags/data-structure/"/>
    
    <category term="javascript" scheme="https://colinchiu87.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Mac 中文輸入法無法顯示選字框？</title>
    <link href="https://colinchiu87.github.io/posts/Mac-bug-inputMethod/"/>
    <id>https://colinchiu87.github.io/posts/Mac-bug-inputMethod/</id>
    <published>2022-10-04T09:05:15.000Z</published>
    <updated>2022-10-17T09:25:10.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有一天在輸入文字的時候，感覺上好像有點怪怪的…，但是又說不出是什麼，打著打著要選字就發現怎麼只能用鍵盤的上下左右盲選字！<br>不知道是不是我自己很少重新開機。<br>趕忙爬文，還以為電腦要壽終正寢了(才用一年多…QAQ</p><span id="more"></span><h2 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h2><p>本人的電腦是 2021 M1 Mac Pro<br>在網路上查到解決的辦法是在終端機上輸入：</p><blockquote><p>killall TCIM_Extension</p></blockquote><p>這個指令是將注音這隻殺掉，然後系統會將殺掉的程式重新開啟，之後就不需要針對單一問題重新開機了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有一天在輸入文字的時候，感覺上好像有點怪怪的…，但是又說不出是什麼，打著打著要選字就發現怎麼只能用鍵盤的上下左右盲選字！&lt;br&gt;不知道是不是我自己很少重新開機。&lt;br&gt;趕忙爬文，還以為電腦要壽終正寢了(才用一年多…QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mac" scheme="https://colinchiu87.github.io/tags/Mac/"/>
    
  </entry>
  
</feed>
